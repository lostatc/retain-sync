#!/usr/bin/env bash

cleanup() {
	kill "$sshfsPID"
	kill "$localPID"
}

fileParse() {
	fileName="$1"
	fileNameEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName")"

	# make sure file is not hidden or under a hidden directory
	[[ "$fileName" =~ /\. ]] && return

	# test if file exists in priority.csv
	fileLine=$(grep -Ex "$fileNameEsc,[0-9\.]*$" "$configDir/priority.csv")

	if [ "$?" -eq 0 ]; then
		# file exists, increase file priority by one
		newPriority=$(echo "scale=6; $(echo "$fileLine" | rev | \
			cut -d ',' -f 1 | rev)+1" | bc)
		sed -i -r "s|^$fileNameEsc,[0-9\.]*$|$fileName,$newPriority|" \
			"$configDir/priority.csv"

		# sleep to prevent file access from being registered multiple times
		sleep 1
	fi
}

configName="$1"
configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName"

# check if specified config exists
if ! [[ -d "$configDir" ]]; then
	>&2 echo "Error: '$configName' is not a valid configuration"
	exit 1
fi

# source variables from config
configError=0
while read -r i; do
	((lineNumber++))

	# line is blank, skip
	[[ "$i" =~ ^$ ]] && continue

	# line is a comment, skip
	[[ "$i" =~ ^# ]] && continue

	# run if line is missing an equals sign
	if ! [[ "$i" =~ = ]]; then
		>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
		((configError++))
	fi

	# parse option, removing leading/trailing whitespace
	varName="$(echo "$i" | cut -d '=' -f 1 | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"
	varValue="$(echo "$i" | cut -d '=' -f 2- | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"

	# check if option is recognized
	if ! echo "$varName" | grep -qFf <(cat <<-EOF
		localDir
		remoteUser
		remoteHost
		port
		remoteDir
		storageLimit
		sshfsOptions
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		>&2 echo "Error: line $lineNumber of config file: unrecognized option '$varName'"
		((configError++))
	fi

	# check if value of boolean options is "yes" or "no"
	if echo "$varName" | grep -Fqf <(cat <<-EOF
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		if [[ "${varValue,,}" != "yes" && "${varValue,,}" != "no" ]]; then
			>&2 echo "Error: line $lineNumber of config file: unrecognized value for boolean option"
			((configError++))
		fi
	fi

	# declare variable
	declare -g "$varName"="$varValue"
done <"$configDir/config"

# exit if there were errors in config file
[[ ! "$configError" -ne 0 ]] || exit 1

# set defaults
sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}"

# format variables
localDir="${localDir%/}"
remoteDir="${remoteDir%/}"
remoteUser="${remoteUser:+$remoteUser@}"
sshfsOptions=(-o "$sshfsOptions" -p "$port")

# escape paths for use in sed substitutions
localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"
configDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir")"

# check if initialization was interrupted
if [[ -f "$localDir/.retain-sync_part" ]]; then
	>&2 echo "Initialization of this directory was interrupted."
	>&2 echo "Please run 'retain-sync initialize' to complete it or 'retain-sync retrieve' to cancel it."
	exit 1
fi

# get environment variables for ssh-agent that aren't available when retain-sync is
# run as a systemd service (there has to be a better way to do this)
[[ -z ${SSH_AGENT_PID+x} ]] && SSH_AGENT_PID="$(pgrep "ssh-agent" | sort -n | \
	head -n 1)"
[[ -z ${SSH_AUTH_SOCK+x} ]] && SSH_AUTH_SOCK="$(find /tmp -user "$USER" -type s \
	-path "/tmp/ssh-*" -name "agent.*" 2> /dev/null | sort -n | head -n 1)"
export SSH_AGENT_PID
export SSH_AUTH_SOCK

while true; do
	# systemd user services can't reference system targets like network-online.target,
	# so we need to have an endless loop here

	# umount sshfs if mountpoint is broken
	mkdir -p "$configDir/mnt" 2> /dev/null
	[[ ! -d "$configDir/mnt" ]] && fusermount -u "$configDir/mnt"

	if ! mountpoint -q "$configDir/mnt"; then
		# mount sshfs
		sshfs "${sshfsOptions[@]}" "$remoteUser$remoteHost:$remoteDir" \
			"$configDir/mnt" 2> /dev/null
	else
		sleep 10
	fi
done &
sshfsPID="$!"

while true; do
	# wait for a file to be opened in local dir
	fileName="$(inotifywait -qre open --format '%w%f' "$localDir")"

	# make sure file is not a directory
	[[ -d "$fileName" ]] || fileParse "$(sed "s|$localDirEsc||" <<< "$fileName")"
done &
localPID="$!"

# run cleanup function on script exit
trap cleanup EXIT

while true; do
	# wait for a file to be opened in remote dir
	fileName="$(inotifywait -qre open --format '%w%f' "$configDir/mnt")" &> /dev/null

	# make sure file is not a directory
	[[ -d "$fileName" ]] || fileParse "$(sed "s|$configDirEsc/mnt||" <<< "$fileName")"
done
