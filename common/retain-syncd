#!/usr/bin/env bash

cleanup() {
	kill "$sshfsPID"
	kill "$localPID"
}

fileParse() {
	fileName="$1"

	# make sure file is not a directory and not hidden or under a hidden directory
	if [[ ! -d "$fileName" ]] && [[ ! "${fileName//$configDir/}" =~ /\. ]]; then
		# test if file exists in priority.csv
		fileLine=$(grep -F "$fileName" "$configDir/priority.csv")

		if [ "$?" -eq 0 ]; then
			# file exists, increase file priority by one
			newPriority=$(echo "scale=6; $(echo "$fileLine" | rev | \
				cut -d ',' -f 1 | rev)+1" | bc)
			sed -i -r "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName"),[0-9\.]*$|$fileName,$newPriority|" \
				"$configDir/priority.csv"

			# sleep to prevent file access from being registered multiple times
			sleep 1
		else
			# new file, priority will be set on next sync operation
			continue
		fi
	else
		# file is hidden or not a normal file
		continue
	fi
}

configName="$1"
configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName"

# check if specified config exists
if ! [[ -d "$configDir" ]]; then
	>&2 printf "\'$configName\' is not a valid configuration. Please run \'retain-sync initialize\'.\n"
	exit 1
fi

# source variables from config
configError=0
while read -r i; do
	((lineNumber++))

	# line is blank, skip
	[[ "$i" =~ ^$ ]] && continue

	# line is a comment, skip
	[[ "$i" =~ ^# ]] && continue

	# run if line is missing an equals sign
	if ! [[ "$i" =~ = ]]; then
		>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
		((configError++))
	fi

	# parse option, removing leading/trailing whitespace
	varName="$(echo "$i" | cut -d '=' -f 1 | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"
	varValue="$(echo "$i" | cut -d '=' -f 2- | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"

	# check if option is recognized
	if ! echo "$varName" | grep -qFf <(cat <<-EOF
		localDir
		remoteUser
		remoteHost
		port
		remoteDir
		storageLimit
		sshfsOptions
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		>&2 printf "Error: line $lineNumber of config file: unrecognized option \'$varName\'"
		((configError++))
	fi

	# check if value of boolean options is "yes" or "no"
	if echo "$varName" | grep -Fqf <(cat <<-EOF
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		if [[ "${varValue,,}" != "yes" && "${varValue,,}" != "no" ]]; then
			>&2 printf "Error: line $lineNumber of config file: unrecognized value for boolean option\n"
			((configError++))
		fi
	fi

	# declare variable
	declare -g "$varName"="$varValue"
done <"$configDir/config"

# exit if there were errors in config file
[[ ! "$configError" -ne 0 ]] || exit 1

# set defaults
sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}"

# format variables
localDir="${localDir%/}"
remoteDir="${remoteDir%/}"
remoteUser="${remoteUser:+$remoteUser@}"
sshfsOptions=(-o "$sshfsOptions" -p "$port")

# escape paths for use in sed substitutions
localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"

# check if initialization was interrupted
if [[ -f "$localDir/.retain-sync_part" ]]; then
	>&2 echo "Initialization of this directory was interrupted."
	>&2 printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
	exit 1
fi

# get environment variables for ssh-agent that aren't available when retain-sync is
# run as a systemd service (there has to be a better way to do this)
[[ -z ${SSH_AGENT_PID+x} ]] && export SSH_AGENT_PID="$(ps aux | grep "garrett" | \
    grep "ssh-agent" | grep -v "grep" | awk '{print $2}' | sort -n | head -n 1)"
[[ -z ${SSH_AUTH_SOCK+x} ]] && export SSH_AUTH_SOCK="$(find /tmp -user "$USER" -type s \
    -path "/tmp/ssh-*" -name "agent.*" 2> /dev/null | sort -n | head -n 1)"

while true; do
	# systemd user services can't reference system targets like network-online.target,
	# so we need to have an endless loop here

	# umount sshfs if mountpoint is broken
	mkdir -p "$configDir/mnt" 2> /dev/null
	[[ ! -d "$configDir/mnt" ]] && fusermount -u "$configDir/mnt"

	if ! mountpoint -q "$configDir/mnt"; then
		# mount sshfs
		sshfs "${sshfsOptions[@]}" "$remoteUser$remoteHost:$remoteDir" \
			"$configDir/mnt" 2> /dev/null
	else
		sleep 10
	fi
done &
sshfsPID="$!"

while true; do
	# wait for a file to be opened in local dir
	fileName="$(inotifywait -qre open --format '%w%f' "$localDir" | \
		sed -r "s|$localDirEsc|$configDir/mnt|")"

	fileParse "$fileName"
done &
localPID="$!"

# run cleanup function on script exit
trap cleanup EXIT

while true; do
	# wait for a file to be opened in remote dir
	fileName="$(inotifywait -qre open --format '%w%f' "$configDir/mnt" | \
		sed -r "s|$localDirEsc|$configDir/mnt|")" &> /dev/null

	fileParse "$fileName"
done
