#!/usr/bin/env bash

configName="$1"
configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName"

# check if specified config exists
if ! [[ -d "$configDir" ]]; then
	>&2 printf "\'$configName\' is not a valid configuration. Please run \'retain-sync initialize\'.\n"
	exit 1
fi

# source variables from config
configError=0
while read -r i; do
	((lineNumber++))

	# line is blank, skip
	[[ "$i" =~ ^$ ]] && continue

	# line is a comment, skip
	[[ "$i" =~ ^# ]] && continue

	# run if line is missing an equals sign
	if ! [[ "$i" =~ = ]]; then
		>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
		((configError++))
	fi

	# parse option, removing leading/trailing whitespace
	varName="$(echo "$i" | cut -d '=' -f 1 | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"
	varValue="$(echo "$i" | cut -d '=' -f 2- | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"

	# check if option is recognized
	if ! echo "$varName" | grep -qFf <(cat <<-EOF
		localDir
		remoteUser
		remoteHost
		remoteDir
		storageLimit
		sshfsOptions
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		>&2 printf "Error: line $lineNumber of config file: unrecognized option \'$varName\'"
		((configError++))
	fi

	# check if value of boolean options is "yes" or "no"
	if echo "$varName" | grep -Fqf <(cat <<-EOF
		deleteAlways
		syncExtraFiles
		inflatePriority
	EOF
	); then
		if [[ "${varValue,,}" != "yes" && "${varValue,,}" != "no" ]]; then
			>&2 printf "Error: line $lineNumber of config file: unrecognized value for boolean option\n"
			((configError++))
		fi
	fi

	# declare variable
	declare -g "$varName"="$varValue"
done <"$configDir/config"

# exit if there were errors in config file
[[ ! "$configError" -ne 0 ]] || exit 1

# set defaults
sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=7,ServerAliveCountMax=3}"

# format variables
localDir="${localDir%/}"
remoteDir="${remoteDir%/}"
remoteUser="${remoteUser:+$remoteUser@}"
sshfsOptions=(-o "$sshfsOptions")

# escape paths for use in sed substitutions
localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"

# check if initialization was interrupted
if [[ -f "$localDir/.retain-sync_part" ]]; then
	>&2 echo "Initialization of this directory was interrupted."
	>&2 printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
	exit 1
fi

# umount sshfs if mountpoint is broken
mkdir -p "$configDir/mnt" 2> /dev/null
[[ ! -d "$configDir/mnt" ]] && fusermount -u "$configDir/mnt"

# mount sshfs if not already mounted
mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
	"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt"
if [[ $? -ne 0 ]]; then
	>&2 echo "Error: unable to mount remote directory over sshfs"
	exit 1
fi

fileParse() {
	fileName="$1"

	# make sure file is not a directory and not hidden or under a hidden directory
	if [[ ! -d "$fileName" ]] && [[ ! "${fileName//$configDir/}" =~ /\. ]]; then
		# test if file exists in priority.csv
		fileLine=$(grep -F "$fileName" "$configDir/priority.csv")

		if [ "$?" -eq 0 ]; then
			# file exists, increase file priority by one
			newPriority=$(echo "scale=6; $(echo "$fileLine" | rev | \
				cut -d ',' -f 1 | rev)+1" | bc)
			sed -i -r "s|$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName"),[0-9\.]*$|$fileName,$newPriority|" \
				"$configDir/priority.csv"

			# sleep to prevent file access from being registered multiple times
			sleep 1
		else
			# new file, priority will be set on next sync operation
			continue
		fi
	else
		# file is hidden or not a normal file
		continue
	fi
}

localWatch() {
	while true; do
		# wait for a file to be opened
		fileName="$(inotifywait -qre open --format '%w%f' "$localDir" | \
			sed -r "s|$localDirEsc|$configDir/mnt|")" || break

		fileParse "$fileName"
	done
}

remoteWatch() {
	while true; do
		# wait for a file to be opened
		fileName="$(inotifywait -qre open --format '%w%f' "$configDir/mnt" | \
			sed -r "s|$localDirEsc|$configDir/mnt|")" || break

		fileParse "$fileName"
	done
}

localWatch &
remoteWatch &

# wait until monitoring fails on both directories before exiting daemon so that access
# to local files can still be recorded without an internet connection
wait

>&2 echo "Error: monitoring failed on both local and remote directories"
exit 1
