#!/usr/bin/env bash

# the current version of the program; this is set by the Makefile
version="@VERSION@"

# disable colored output if stdout is being redirected
if [[ -t 1 ]]; then
	# set colors for colored output
	cBG="$(tput bold)$(tput setaf 2)"	# bold green
	cBR="$(tput bold)$(tput setaf 1)"	# bold red
	cN="$(tput sgr0)"					# normal
fi

usage() {
	cat <<-EOF
		Usage: ${cBR}retain-sync${cN} [${cBG}global_options${cN}] ${cBG}command${cN} [${cBG}command_options${cN}] [${cBG}command_arg${cN}]

		Global options:
		        ${cBR}--help${cN}		Display this usage message and exit.
		        ${cBR}--version${cN}	Print version number and exit.
		    ${cBR}-q${cN}, ${cBR}--quiet${cN}		Suppress all non-error output.

		Commands:
		    ${cBR}initialize${cN} [${cBG}options${cN}] ${cBG}path${cN}
		        Prepare the local directory ${cBG}path${cN} for syncing by moving it to the server and
		        generating a configuration for it.

		        ${cBR}-e${cN}, ${cBR}--exclude${cN} ${cBG}file${cN}
		            Get a list of file/directory paths from ${cBG}file${cN} (one per line) that will be
		            excluded from syncing, meaning that they will never leave the local
		            machine. If ${cBG}file${cN} is '-', then a newline-separated list of file paths will
		            be accepted from stdin.

		    ${cBR}sync${cN} ${cBG}config${cN}|${cBG}path${cN}
		        Redistribute files between the local and remote directories based on their
		        priority and update the server with any new or deleted files. This command
		        accepts the absolute path of a local initialized directory or the name of its
		        configuration.

		    ${cBR}retrieve${cN} ${cBG}config${cN}|${cBG}path${cN}
		        Retrieve all files from the server and de-initialize the local directory. This
		        command accepts the absolute path of a local initialized directory or the name
		        of its configuration.

		    ${cBR}list-configs${cN}
		        Print a table of all initialized directories and the names of their
		        configurations.

		    ${cBR}empty-trash${cN} ${cBG}config${cN}|${cBG}path${cN}
		        Permanently delete all files on the server that are marked for deletion. This
		        command accepts the absolute path of a local initialized directory or the name
		        of its configuration.
	EOF
}

readConfig() {
	# accepts either the name of a configuration or the absolute path of a local
	# sync directory
	if [[ -d "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$1" ]]; then
			# parameter is a valid config
			configName="$1"
	elif [[ "$1" =~ ^~?/ ]]; then
		# parameter is an absolute path
		if [[ -f "$1/.retain-sync_init" ]]; then
			# parameter is an initialized directory
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_init")
		elif [[ -f "$1/.retain-sync_part" ]]; then
			# directory initialization was interrupted
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_part")
		else
			>&2 echo "Error: '$1' is not an initialized directory"
			exit 1
		fi
	else
		>&2 echo "Error: '$1' is not a valid configuration or an absolute path"
		exit 1
	fi
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName

	# source variables from config
	configError=0
	while read -r i; do
		((lineNumber++))

		# line is blank, skip
		[[ "$i" =~ ^$ ]] && continue

		# line is a comment, skip
		[[ "$i" =~ ^# ]] && continue

		# run if line is missing an equals sign
		if ! [[ "$i" =~ = ]]; then
			>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
			((configError++))
		fi

		# parse option, removing leading/trailing whitespace
		varName="$(cut -d '=' -f 1 <<< "$i" | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')In"
		varValue="$(cut -d '=' -f 2- <<< "$i" | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')"

		# check if option is recognized
		if ! echo "$varName" | grep -Fqf <(cat <<-EOF
			localDir
			remoteUser
			remoteHost
			port
			remoteDir
			storageLimit
			sshfsOptions
			deleteAlways
			syncExtraFiles
			inflatePriority
		EOF
		); then
			>&2 echo "Error: line $lineNumber of config file: unrecognized option '$varName'"
			((configError++))
		fi

		# check if value of boolean options is "yes" or "no"
		if echo "$varName" | grep -qFf <(cat <<-EOF
			deleteAlways
			syncExtraFiles
			inflatePriority
		EOF
		); then
			if [[ "${varValue,,}" != "yes" && "${varValue,,}" != "no" ]]; then
				>&2 echo "Error: line $lineNumber of config file: unrecognized value for boolean option"
				((configError++))
			fi
		fi

		# declare variable
		declare -g "$varName"="$varValue"
	done <"$configDir/config"

	# exit if there were errors in config file
	[[ $configError -ne 0 ]] && exit 1

	# set defaults
	sshfsOptions="${sshfsOptionsIn:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}"
	deleteAlways="${deleteAlwaysIn:-no}"
	syncExtraFiles="${syncExtraFilesIn:-yes}"
	inflatePriority="${inflatePriorityIn:-yes}"
	sshOptions=(-o ServerAliveInterval=5 -o ServerAliveCountMax=3 -p "$portIn")

	# format variables
	localDir="${localDirIn%/}"
	remoteUser="${remoteUserIn:+$remoteUserIn@}"
	remoteHost="$remoteHostIn"
	remoteDir="${remoteDirIn%/}"
	storageLimit="$(sed -r -e 's/KB?/\*1024/' -e 's/MB?/\*1048576/' \
		-e 's/GB?/\*1073741824/' <<< "$storageLimitIn" | bc)"
	sshfsOptions=(-o "$sshfsOptions" -o "nonempty" -p "$portIn")
	deleteAlways="${deleteAlways,,}"
	syncExtraFiles="${syncExtraFiles,,}"
	inflatePriority="${inflatePriority,,}"

	# escape paths for use in sed substitutions
	localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"
	remoteDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$remoteDir")"
	configDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir")"
}

fileLock() {
	# open lock file
	exec 200>"$localDir/.retain-sync_lock"
	flock -n 200

	# run if lock file was already open
	if [[ "$?" -ne 0 ]]; then
		>&2 echo "Error: another operation on this configuration is already running"
		exit 1
	fi
}

sshMaster() {
	# add ControlPath to ssh defaults
	sshOptions+=(-S "$XDG_RUNTIME_DIR/retain-sync/%C.sock")

	# create runtime dir if it doesn't already exist
	mkdir -p "$XDG_RUNTIME_DIR/retain-sync"

	# all subsequent ssh commands (excluding sshfs)  will use this master connection
	# instead of reconnecting each time
	ssh "${sshOptions[@]}" -fNM "$remoteUser$remoteHost"
}

genConfig() {
	# prompt user for name of config
	while true; do
		read -erp "Enter a name for this configuration: " configName </dev/tty
		configName="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$configName")"
		if [[ -z "$configName" ]]; then
			>&2 echo "Error: this value may not be blank"
		elif [[ "$configName" =~ [\ ]+ ]]; then
			>&2 echo "Error: this value may not contain spaces"
		elif [[ "$configName" =~ [^0-9A-Za-z_-]+ ]]; then
			>&2 echo "Error: only alphanumeric characters, hyphens and underscores are allowed"
		else
			break
		fi
	done

	# prompt user for user name on remote machine
	while true; do
		read -erp "Enter your user name on the remote machine (empty to use local user name): " remoteUserIn </dev/tty
		remoteUserIn="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteUserIn")"
		if [[ "$remoteUserIn" =~ [\ ]+ ]]; then
			>&2 echo "Error: user name may not contain spaces"
		else
			break
		fi
	done

	# prompt user for hostname of remote machine
	while true; do
		read -erp "Enter the hostname, ip address or domain name of the remote machine: " remoteHostIn </dev/tty
		remoteHostIn="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteHostIn")"
		if [[ -z "$remoteHostIn" ]]; then
			>&2 echo "Error: this value may not be blank"
		elif [[ "$remoteHostIn" =~ [\ ]+ ]]; then
			>&2 echo "Error: hostname may not contain spaces"
		else
			break
		fi
	done

	# prompt user for port number
	while true; do
		read -erp "Enter the port number to connect to on the remote machine (defaults to port 22): " portIn </dev/tty
		if [[ -z "$portIn" ]]; then
			portIn=22
			break
		elif ! [[ "$portIn" =~ ^[0-9]+$ ]]; then
			>&2 echo "Error: value must be a number in the range 0-65535"
		elif [[ "$portIn" -lt 1 || "$portIn" -gt 65535 ]]; then
			>&2 echo "Error: value must be a number in the range 0-65535"
		else
			break
		fi
	done

	# prompt user for directory to sync to on remote machine
	while true; do
		read -erp "Enter the directory to sync to on the remote machine: " remoteDirIn </dev/tty
		remoteDirIn="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteDirIn")"
		if [[ -z "$remoteDirIn" ]]; then
			>&2 >&2 echo "Error: this value may not be blank"
		elif [[ ! "$remoteDirIn" =~ ^/ ]]; then
			>&2 echo "Error: must be an absolute path"
		else
			break
		fi
	done

	# prompt user for storage limit
	while true; do
		read -erp "Enter the amount of data to keep synced locally to this machine (accepts K, M or G): " storageLimitIn </dev/tty
		if [[ ! "$storageLimitIn" =~ ^[0-9]+(K|M|G|KB|MB|GB)$ ]]; then
			>&2 echo "Error: must be a whole number followed by a unit (e.g. 10G)"
		else
			break
		fi
	done

	# set default options
	sshfsOptions="reconnect,ServerAliveInterval=5,ServerAliveCountMax=3"
	deleteAlways="no"
	syncExtraFiles="yes"
	inflatePriority="yes"

	# check if config name is unique
	IFS=$'\n'
	if grep -Fxq "$configName" <(basename -a $(printf "%s\n" "${configDirs[@]}") 2> /dev/null); then
		uniqueConfigName="no"
		>&2 echo "Error: the name '$configName' is already in use"
		exit 1
	fi
	unset IFS

	# create config directory
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName
	mkdir "$configDir"

	# create config file
	cat <<-EOF > "$configDir/config"
		#
		# retain-sync config
		#

		# directory to sync on local machine
		localDir=$localDir

		# user name on remote machine (optional)
		remoteUser=$remoteUserIn

		# hostname, ip address or domain name of remote machine
		remoteHost=$remoteHostIn

		# port number to connect to on remote machine
		port=$portIn

		# directory to sync to on remote machine
		remoteDir=$remoteDirIn

		# amount of data to keep on local machine (accepts K, M or G)
		storageLimit=$storageLimitIn


		# mount options to pass to sshfs
		#sshfsOptions=$sshfsOptions

		# always delete files from the server when their local counterparts are
		# deleted, even if copies aren't found in the local user's trash
		#deleteAlways=$deleteAlways

		# start syncing individual files once no more whole directories can fit within
		# the storage limit
		#syncExtraFiles=$syncExtraFiles

		# inflate the priority of new local files so that they stick around longer
		#inflatePriority=$inflatePriority
	EOF
}

initializeDir() {
	# function accepts the absolute path of a local directory as a parameter

	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u 200

		# inform user if initialization is interrupted
		if [[ "$uniqueConfigName" != "no" ]]; then
			if [[ -f "$localDir/.retain-sync_part" ]]; then
				printf "\n%s\n" "Initialization was interrupted."
				echo "Please run 'retain-sync initialize' to complete it or 'retain-sync retrieve' to cancel it."
			elif ! [[ -f "$localDir/.retain-sync_init" ]]; then
				rm -rf "$configDir"
			fi
		fi
	}

	# test if parameter is an absolute path
	if [[ "$1" =~ ^~?/ ]]; then
		# is an absolute path
		localDir="${1%/}" # remove trailing slash
	else
		# not an absolute path
		>&2 echo "Error: must be an absolute path"
		exit 1
	fi

	# check if local directory exists
	if ! [[ -d "$1" ]]; then
		>&2 echo "Error: no such directory '$localDir'"
		exit 1
	fi

	# check argument for --exclude option
	if [[ -n "$optExcludeFile" ]]; then
		if [[ "$optExcludeFile" == "-" ]]; then
			# read contents of stdin to array
			mapfile -t excludeInputFiles
		elif [[ -f "$optExcludeFile" ]]; then
			# read contents of exclude input file to array
			mapfile -t excludeInputFiles < "$optExcludeFile"
		else
			# argument is invalid
			>&2 echo "Error: input file is invalid"
			exit 1
		fi
	fi

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# don't run if finishing an interrupted initialization
	if [[ ! -f "$localDir/.retain-sync_part" ]]; then
		# check if directory has already been initialized
		if [[ -f "$localDir/.retain-sync_init" ]]; then
			>&2 echo "Error: the specified directory has already been initialized by '$(cat "$localDir/.retain-sync_init")'"
			exit 1
		fi

		# check if directory includes the retain-sync config
		if find "$localDir" -type d | grep -Fq "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync"; then
			>&2 echo "Error: the specified directory contains retain-sync config files"
			exit 1
		fi

		# check if directory overlaps with another retain-sync configuration
		IFS=$'\n'
		configDirs=($(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" \
			-mindepth 1 -maxdepth 1 -type d))
		if [[ "${#configDirs[@]}" -gt 0 ]]; then
			while read -r i; do
				localDirTest="$(grep "localDir=" "$i/config" | cut -d '=' -f 2-)"
				localTreeTest=($(find "$localDirTest" -type d))
				localTree=($(find "$localDir" -type d))
				if [[ -n "$(printf "%s\n" "${localTreeTest[@]}" "${localTree[@]}" | sort | uniq -d)" ]]; then
					>&2 echo "Error: the specified directory overlaps with the configuration '$(basename "$i")'"
					exit 1
				fi
			done < <(printf "%s\n" "${configDirs[@]}")
		fi
		unset IFS

		# generate config and source variables from it
		genConfig

		# set defaults
		sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}"
		sshOptions=(-o ServerAliveInterval=5 -o ServerAliveCountMax=3 -p "$portIn")

		# format variables
		remoteUser="${remoteUserIn:+$remoteUserIn@}"
		remoteHost="$remoteHostIn"
		remoteDir="${remoteDirIn%/}"
		sshfsOptions=(-o "$sshfsOptions" -o "nonempty" -p "$portIn")

		# escape paths for use in sed substitutions
		localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"
		configDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir")"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "mkdir -p '$remoteDir'" || exit 1

		# check if remote directory is empty
		if [[ -n "$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "find '$remoteDir' -mindepth 1")" ]]; then
			>&2 printf "\n%s\n" "Error: remote directory is not empty"
			exit 1
		fi

		# add all local symlinks to the exclude file so they don't get clobbered (this
		# does not include symlinks to directories)
		cat <<-EOF > "$configDir/exclude"
			# This file contains paths to files/directories to exclude from syncing.
			#
			# The root of each file/directory path is anchored to the local initialized
			# directory (see retain-sync(1) for details).
			#
			# All user-created symbolic links in the local initialized directory are added
			# to this file automatically.
		EOF
		find "$localDir" -not -path '*/\.*' -type l | sed -r "s|$localDirEsc||" >> \
			"$configDir/exclude"

		IFS=$'\n'
		localFiles=($(find "$localDir" -mindepth 1 -not -path '*/\.*' | sed -r "s|$localDirEsc||"))
		unset IFS

		# run if --exclude option was given
		if [[ -n "$optExcludeFile" ]]; then
			for i in "${excludeInputFiles[@]}"; do
				[[ "$i" =~ ^$ ]] && continue	# skip empty line
				[[ "$i" =~ ^# ]] && continue	# skip commented line

				# add leading slash if it doesn't exist
				[[ "$i" =~ ^/ ]] || i="/$i"

				# if it exists in the local sync directory, copy file path from input file
				# to exclude file
				i="${i/"$localDirEsc"/}"
				if grep -Fxqf <(printf "%s\n" "${localFiles[@]}") <<< "${i%/}"; then
					echo "$i" >> "$configDir/exclude"
				fi
			done
		fi

		# generate file indicating that the initialization process is in progress
		echo "$configName" > "$localDir/.retain-sync_part"
	else
		echo "Resuming initialization..."

		# read config file
		readConfig "$1"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "mkdir -p '$remoteDir'" || \
			exit 1
	fi

	# check if there is enough space on the server
	printf "\n%s" "Checking space requirement... "
	remoteSpace=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		"df -B 1 '$remoteDir'" | tail -n 1 | awk '{print $4}')
	localSize=$(du -sb "$localDir" | awk '{print $1}')
	if [[ "$localSize" -gt "$remoteSpace" ]]; then
		>&2 printf "\n%s\n" "Error: not enough free space on the server"
		exit 1
	else
		echo "done"
	fi

	# copy local files to the server
	printf "%s" "Copying local files to server... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --exclude=".*" \
		--exclude-from="$configDir/exclude" "$localDir/" \
		"$remoteUser$remoteHost:$remoteDir" && echo "done" || exit 1

	# Note: the purpose of this directory is to ensure that any commands that interact
	# with it (e.g. find $configDir/mnt/.dest/..) fail when sshfs isn't mounted
	mkdir -p "$configDir/mnt/.dest"
	chmod 000 "$configDir/mnt/.dest"

	# mount sshfs
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt"
	if [[ $? -ne 0 ]]; then
		>&2 echo "Error: unable to mount remote directory over sshfs"
		exit 1
	fi

	mkdir "$configDir/mnt/.dest"

	# replace local files with symlinks unless local directory is empty
	if [[ -n "${localFiles[@]}" ]]; then
		printf "%s" "Replacing local files with symbolic links... "
		cp -asf "$configDir"/mnt/* "$localDir" && echo "done"
	fi

	# create priority.csv file containing a list of all files in the tree followed
	# by a starting priority of zero
	echo "# Editing this file by hand is not recommended." > "$configDir/priority.csv"
	find "$configDir/mnt/.dest/.." -not -type d -exec echo '{},0' \; | \
		sed -r "s|$configDirEsc/mnt/\.dest/\.\.||" >> "$configDir/priority.csv" || exit 1

	# create "init" file used to indicate that the directory has been initialized and
	# what the name of its config is
	mv "$localDir/.retain-sync_part" "$localDir/.retain-sync_init"

	# advise user to start/enable the daemon
	printf "\n%s\n" "Run 'systemctl --user start retain-sync@$configName.service' to start the daemon."
	echo "Run 'systemctl --user enable retain-sync@$configName.service' to start the daemon automatically on login."
}

syncDir() {
	cleanup() {
		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u 200

		# delete temp file
		rm -f "$dirPriorityFile"
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# get environment variables for ssh-agent that aren't available when retain-sync is
	# run as a systemd service (there has to be a better way to do this)
	[[ -z ${SSH_AGENT_PID+x} ]] && SSH_AGENT_PID="$(pgrep "ssh-agent" | sort -n | \
		head -n 1)"
	[[ -z ${SSH_AUTH_SOCK+x} ]] && SSH_AUTH_SOCK="$(find /tmp -user "$USER" -type s \
		-path "/tmp/ssh-*" -name "agent.*" 2> /dev/null | sort -n | head -n 1)"
	export SSH_AGENT_PID
	export SSH_AUTH_SOCK

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync retrieve' to cancel it."
		exit 1
	fi

	# umount sshfs if mountpoint is broken
	mkdir -p "$configDir/mnt/.dest" 2> /dev/null
	[[ ! -d "$configDir/mnt" ]] && fusermount -u "$configDir/mnt"

	# mount sshfs if not already mounted
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt"
	if [[ $? -ne 0 ]]; then
		>&2 echo "Error: unable to mount remote directory over sshfs"
		exit 1
	fi

	printf "%s" "Checking for new files... "

	# read contents of exclude file into an array of file paths
	IFS=$'\n'
	while read -r i; do
		[[ "$i" =~ ^$ ]] && continue # skip line if empty
		[[ "$i" =~ ^# ]] && continue # skip line if a comment

		i="$localDir$i"
		[[ -e "$i" ]] && excludeFiles+=($(find "$i" -not -path '*/\.*' -not -type d))
	done <"$configDir/exclude"

	# remove excluded files from priority.csv
	for i in "${excludeFiles[@]}"; do
		i="$(sed -r "s|$localDirEsc||" <<< "$i")"
		sed -i -r -e "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i"),[0-9\.]*$||" -e '/^$/d' \
			"$configDir/priority.csv"
	done

	# remove broken symlinks that aren't in the exclude file
	find "$localDir" -xtype l | grep -Fxvf <(printf "%s\n" "${excludeFiles[@]}") | \
		xargs -d '\n' rm -f

	# get list of files that have been created or removed since last sync operation
	#
	# 1) print list of files/symlinks in local directory that aren't in the exclude
	#	 file (making paths relative)
	# 2) concatenate list of files in priority.csv (making paths relative)
	# 3) remove all repeated entries in the list
	diffFiles=($(printf "%s\n" "$(find "$localDir" -not -path '*/\.*' -not -type d | \
		grep -Fvxf <(printf "%s\n" "${excludeFiles[@]}") | \
		sed -r "s|$localDirEsc||")" "$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 2- | rev)" | sort | uniq -u))
	unset IFS

	# find highest priority in the file priority file and add 1 to it
	newPriority="$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 1 | rev | sort -nr | head -n 1 | \
		awk '{print "scale=6; " $0 "+1"}' | bc)" 2> /dev/null

	# go through files that have chaged since the last sync one at a time
	for i in "${diffFiles[@]}"; do
		iEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< $i)"

		if grep -Exq "$iEsc,[0-9\.]*" "$configDir/priority.csv"; then
			# file is no longer present in local directory, remove from priority file
			sed -i -r -e "s|^$iEsc,[0-9\.]*$||" -e '/^$/d' "$configDir/priority.csv"

			if [[ "$deleteAlways" == "no" ]]; then
				# compute checksums of all files in the user's trash if it hasn't already
				# been done
				IFS=$'\n'
				if [[ -z "${trashSums+x}" ]]; then
					trashSums=($(find "${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files" \
						-not -type d -not -type l -print0 | xargs -0 md5sum | sort | \
						uniq -w 32))
				fi
				unset IFS

				# compute checksum of current file
				fileSum="$(md5sum "$configDir/mnt/.dest/..$i")"

				# test if file exists in the user's local trash directory by comparing checksums
				if [[ -n "$(printf "%s\n" "${trashSums[@]}" "$fileSum" | sort | uniq -w 32 -D)" ]]; then
					# file is in trash, delete corresponding file on the server
					rm "$configDir/mnt/.dest/..$i" || exit 1
				else
					# file is not in trash, mark corresponding file on the server for deletion
					mv "$configDir/mnt/.dest/..$i" \
						"$configDir/mnt/.dest/..$(dirname "$i")/.$(basename "$i").trash" || exit 1
				fi
			else
				# $deleteAlways is set to 'yes', delete corresponding file on the server
				rm "$configDir/mnt/.dest/..$i" || exit 1
			fi
		else
			# new file
			if [[ -L "$localDir$i" ]]; then
				# file is a symlink, add to exclude file
				echo "$i" >> "$configDir/exclude"
			else
				# file is not a symlink, add to priority.csv
				if [[ "$inflatePriority" == "yes" ]]; then
					# set priority so that it's at the top
					echo "$i,${newPriority:-0}" >> "$configDir/priority.csv"
				else
					# set priority to zero
					echo "$i,0" >> "$configDir/priority.csv"
				fi

				# total size of all new files
				((newFilesSize+="$(du -b "$localDir$i" | awk '{print $1}')"))
			fi
		fi
	done

	# delete broken symlinks in local directory
	find "$localDir" -xtype l -exec rm '{}' \;

	# exit if priority.csv is empty
	if ! grep -vq '^#' "$configDir/priority.csv"; then
		echo "Local directory is empty. There is nothing else to do."
		exit 0
	fi

	# check if there's enough space on the server for the new files
	remoteSpace=$(df -B 1 "$configDir/mnt/.dest/.." | tail -n 1 | awk '{print $4}') || \
		exit 1
	if [[ "$newFilesSize" -gt "$remoteSpace" ]]; then
		>&2 printf "\n%s\n" "Error: not enough free space on the server"
		exit 1
	fi

	# upload new files and files that have changed since the last sync
	rsync -aHAXSu --exclude-from="$configDir/exclude" --exclude=".*" --safe-links \
		"$localDir/" "$configDir/mnt/.dest/.." || exit 1

	echo "done"

	printf "%s" "Sorting directories by priority... "

	# create directory priority file containing a list of all directories in the
	# tree
	dirPriorityFile="$(mktemp)"
	find "$configDir/mnt/.dest/.." -mindepth 1 -type d | sed -r \
		"s|$configDirEsc/mnt/\.dest/\.\.||" > "$dirPriorityFile" || exit 1

	# read directory priority file line-by-line
	while read -r i; do
		# total the priorities of all the files in each directory to get the
		# directory priority
		dirPriority=$(grep -v '^#' "$configDir/priority.csv" | grep -F "$i/" | rev | \
			cut -d ',' -f 1 | rev | tr '\n' '+' | sed 's/\+$/\n/' | \
			awk '{print "scale=6; " $0}'| bc) 2> /dev/null

		# get the size of the directory in bytes
		dirSize="$(du -sb "$configDir/mnt/.dest/..$i" | awk '{print $1}')" || exit 1

		# set minimum dir size of 16 bytes to perclude a "divide by zero"
		# error with bc
		[[ "$dirSize" -lt 16 ]] && dirSize=16

		# adjust directory priority for the number of files and the size of the
		# directory
		# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
		# numbers easier to work with
		dirPriority=$(echo "scale=6; ${dirPriority:-0}/($dirSize/10485760)" | bc)

		# write directory priority to file
		sed -i -r "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")$|$i,$dirPriority|" \
			"$dirPriorityFile"
	done <"$dirPriorityFile"

	# sort directory priority file and remove priorities, leaving just file paths
	awk -F ',' '{print $NF,$0}' "$dirPriorityFile" | sort -rn | \
		cut -d ' ' -f 2- > "$dirPriorityFile.swp"
	mv "$dirPriorityFile.swp" "$dirPriorityFile"
	sed -i 's/,[0-9\.]*$//' "$dirPriorityFile"

	# cut down the directory priority file to only the list of directories that can be
	# stored locally without exceeding the storage limit
	while true; do
		syncSize=0

		while read -r i; do
			dirSize="$(du -sb "$configDir/mnt/.dest/..$i" | awk '{print $1}')" || exit 1

			if [[ "$dirSize" -gt $storageLimit ]]; then
				# current directory alone is larger than the storage limit, remove from
				# directory priority file
				grep -Fv "$i" "$dirPriorityFile" > "$dirPriorityFile.swp"
				mv "$dirPriorityFile.swp" "$dirPriorityFile"
			else
				# get size of current directory in bytes and add it to the total
				# size of the list
				((syncSize+=dirSize))

				if [[ "$syncSize" -gt $storageLimit ]]; then
					# total list size has exceeded the storage limit
					if ! grep -Fqxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile"; then
						# none of the directories in the list have subdirectories in
						# the list, remove current directory from the directory
						# priority file because it is too large to fit within the
						# storage limit
						grep -Fv "$i" "$dirPriorityFile" > "$dirPriorityFile.swp"
						mv "$dirPriorityFile.swp" "$dirPriorityFile"

						((syncSize-=dirSize))
					else
						break
					fi
				else
					# total list size is still within the storage limit

					dirPriorityTree+=($(find "$configDir/mnt/.dest/..$i" -mindepth 1 -type d | \
						sed -r "s|$configDirEsc/mnt/\.dest/\.\.||")) || exit 1

					# check if the while loop has reached the last line of the directory
					# priority file
					if [[ "$(tail -n 1 "$dirPriorityFile")" == "$i" ]]; then
						# the list is complete, break out of loops
						break 2
					fi
				fi
			fi
		done <"$dirPriorityFile"

		# break if file is empty
		[[ ! -s "$dirPriorityFile" ]] && break

		# remove subdirectories of directories in the list from the directory priority
		# file
		grep -Fvxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile" > "$dirPriorityFile.swp"
		mv "$dirPriorityFile.swp" "$dirPriorityFile"
	done
	echo "done"

	# get list of individual files that aren't included in the directory priority file
	printf "%s" "Sorting remaining files by priority... "
	IFS=$'\n'
	noSyncFiles=($(find "$configDir/mnt/.dest/.." -not -name '.*.trash' -not -type d | \
		sed -r "s|$configDirEsc/mnt/\.dest/\.\.||")) || exit 1
	while read -r i; do
		noSyncFiles+=($(find "$configDir/mnt/.dest/..$i" -not -name '.*.trash' -not \
			-type d | sed -r "s|$configDirEsc/mnt/\.dest/\.\.||")) || exit 1
	done <"$dirPriorityFile"
	noSyncFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sort | uniq -u))

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# from that list, get list of individual files that can fill the remaining space
		# until the storage limit is reached

		for i in "${noSyncFiles[@]}"; do
			# search for line containing complete file name in priority file
			noSyncSorted+=($(grep -Ex "^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i"),[0-9\.]*$" \
				"$configDir/priority.csv"))
		done

		# adjust priority for file size
		for i in "${!noSyncSorted[@]}"; do
			currentFile="$(rev <<< "${noSyncSorted[$i]}" | cut -d ',' -f 2- | rev)"
			currentFileSize=$(du -sb "$configDir/mnt/.dest/..$currentFile" | \
				awk '{print $1}') || exit 1

			# set minimum file size of 16 bytes to perclude a "divide by zero"
			# error with bc
			if [[ "$currentFileSize" -lt 16 ]]; then
				currentFileSize=16
			fi

			# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
			# numbers easier to work with
			adjustedPriority=$(echo "scale=6; $(rev <<< "${noSyncSorted[$i]}" | \
				cut -d ',' -f 1 | rev)/($currentFileSize/10485760)" | bc)
			noSyncSorted[$i]="$(sed "s/,[0-9\.]*$/,$adjustedPriority/" <<< \
				"${noSyncSorted[$i]}")"
		done

		# sort files by priority
		noSyncSorted=($(printf "%s\n" "${noSyncSorted[@]}" | awk -F ',' '{print $NF,$0}' | \
			sort -rn | cut -d ' ' -f 2- | rev | cut -d ',' -f 2- | rev))
		unset IFS

		for i in "${noSyncSorted[@]}"; do
			currentFileSize=$(du -sb "$configDir/mnt/.dest/..$i" | \
				awk '{print $1}') || exit 1

			# get size of current file in bytes and add it to the total size
			((syncSize+=currentFileSize))

			# check if the total size of the list has exceeded the storage limit
			if [[ "$syncSize" -gt "$storageLimit" ]]; then
				# current file is too big, skip to next one
				((syncSize-=currentFileSize))
			else
				# add current file to the extra files list
				extraFiles+=("$i")
			fi
		done
	fi

	# get list of individual files to remove and change their path context
	if [[ "$syncExtraFiles" == "yes" ]]; then
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" "${extraFiles[@]}" | sort | uniq -u | \
			sed "s|^|$localDir|"))
		unset IFS
		echo "done"
	else
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sed "s|^|$localDir|"))
		unset IFS
		echo "done"
	fi

	# remove files that aren't in the directory priority file or the extra files list
	printf "%s" "Removing unused files... "
	printf "%s\n" "${rmFiles[@]}" | xargs -d '\n' rm -f

	# replace missing files with symlinks
	cp -asn "$configDir"/mnt/* "$localDir" &> /dev/null

	# remove symlinks to files marked for deletion
	find "$configDir/mnt/.dest/.." -not -type d -name '.*.trash' | \
		sed -r "s|$configDirEsc/mnt/\.dest/\.\.|$localDir|" | xargs -d '\n' rm -f || \
			exit 1

	# remove empty directories
	find "$localDir" -not -path '*/\.*' -type d -empty -delete
	echo "done"

	printf "%s" "Downloading new files... "

	# download (and remove from the server) excluded files that are still on the server
	find "$configDir/mnt/.dest/.." -not -type d | sed -r \
		"s|$configDirEsc/mnt/\.dest/\.\.||" | grep -Fxf <(printf "%s\n" \
		"${excludeFiles[@]}" | sed -r "s|$localDirEsc||") | rsync -asHAXS \
		--files-from=- --remove-source-files "$configDir/mnt/.dest/../" \
		"$localDir" || exit 1

	# find file paths in directory priority file
	IFS=$'\n'
	while read -r i; do
		downloadFiles+=($(find "$configDir/mnt/.dest/..$i" -not -type d -not -name \
			'.*.trash' | sed -r "s|$configDirEsc/mnt||")) || exit 1
	done <"$dirPriorityFile"
	unset IFS

	# download directories that are in the directory priority file but not stored
	# locally
	printf "%s\n" "${downloadFiles[@]}" | rsync -asHAXS --files-from=- \
		--exclude-from="$configDir/exclude" "$configDir/mnt/.dest/../" "$localDir" || \
		exit 1

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# fill the remaining space with the highest-priority individual files that
		# haven't already been downloaded
		printf "%s\n" "${extraFiles[@]}" | rsync -asHAXS --files-from=- \
			"$configDir/mnt/.dest/../" "$localDir" || exit 1
	fi
	echo "done"
}

retrieveDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# check if systemd service is running
	systemctl --user status "retain-sync@$configName.service" &> /dev/null
	if [[ "$?" -eq 0 ]]; then
		>&2 echo "Error: retain-sync@$configName.service is running"
		echo "Please stop and disable the service before proceeding."
		exit 1
	fi

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if there is enough free space on the local machine
	printf "%s" "Checking space requirement... "
	remoteSize=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		"du -sb '$remoteDir'" | awk '{print $1}') || exit 1
	localSpace=$(df -B 1 "$localDir" | tail -n 1 | awk '{print $4}')
	if [[ "$remoteSize" -gt "$localSpace" ]]; then
		# not enough space
		>&2 printf "\n%s\n" "Error: not enough free space on this machine to retrieve '$configName'"
		exit 1
	else
		echo "done"
	fi

	# read contents of exclude file into an array of file paths
	printf "%s" "Removing symbolic links from local directory... "
	while read -r i; do
		i="$localDir$i"
		[[ -a "$i" ]] && \
			excludeFiles+=($(find "$i" -not -path '*/\.*' -not -type d))
	done <"$configDir/exclude"

	# remove symlinks that aren't in the exclude file from the local directory
	find "$localDir" -not -path '*/\.*' -type l | \
		grep -Fxvf <(printf "%s\n" "${excludeFiles[@]}") | \
		xargs -d '\n' rm -f && echo "done"

	# move files from remote directory back to local directory
	printf "%s" "Moving remote files to local machine... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --remove-source-files \
		"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1

	# remove empty directories
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "find '$remoteDir' -type d -empty -delete" && \
		echo "done" || exit 1

	printf "%s" "Cleaning up... "

	# unmount sshfs, remove init file, lock file and config directory
	if mountpoint -q "$configDir/mnt" || [[ ! -d "$configDir/mnt" ]]; then
		fusermount -u "$configDir/mnt" || exit 1
	fi
	rm -f "$localDir/.retain-sync_init" "$localDir/.retain-sync_part" \
		"$localDir/.retain-sync_lock"
	chmod 700 "$configDir/mnt/.dest"
	rm -r "$configDir"
	echo "done"
}

listConfigs() {
	# get a list of directory paths that have been initialized and the names of their
	# configurations
	IFS=$'\n'
	while read -r i; do
		configName+=($(basename "$i"))
		localDir+=($(grep "localDir=" "$i/config" | cut -d '=' -f 2-))
	done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" \
		-mindepth 1 -maxdepth 1 -type d)
	unset IFS

	if [[ "${#configName[@]}" -eq 0 ]]; then
		printf "\n%s\n\n" "-- No configs --"
		return 0
	fi

	# find length of longest configuration name or "Configuration"
	configLength=$(printf "%s\n" "${configName[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	configLength=$((configLength>13 ? configLength:13))

	# find length of longest local directory path or "Local directory"
	dirLength=$(printf "%s\n" "${localDir[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	dirLength=$((dirLength>15 ? dirLength:15))

	# print header
	printf "%-${configLength}s | %-s\n" "Configuration" "Local directory"

	# print horizontal separator
	printf '%.0s-' $(seq 1 $((configLength+1)))
	printf '+'
	printf '%.0s-' $(seq 1 $((dirLength+1)))

	# print rest of table
	paste -d ' ' <(printf "\n%-${configLength}s |" "${configName[@]}") <(printf "\n%-s" "${localDir[@]}")
}

emptyTrash() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync retrieve' to cancel it."
		exit 1
	fi

	# get list of files marked for deletion
	IFS=$'\n'
	trashFiles=($(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		"find '$remoteDir' -not -type d -name '.*.trash'")) || exit 1
	unset IFS

	# delete files if there are any
	if [[ "${#trashFiles[@]}" -gt 0 ]]; then
		printf "%s" "Emptying trash... "
		printf "%s\n" "${trashFiles[@]}" | ssh "${sshOptions[@]}" \
			"$remoteUser$remoteHost" "xargs -d '\n' rm"
		echo "done"
		echo "${#trashFiles[@]} files deleted"
	else
		echo "No files to delete"
	fi
}

agePriority() {
	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync retrieve' to cancel it."
		exit 1
	fi

	# divide the priority of every file by 1.1
	while read -r i; do
		fileName="$(rev <<< "$i" | cut -d ',' -f 2- | rev)"
		newPriority=$(echo "scale=6; $(rev <<< "$i" | cut -d ',' -f 1 | rev)/1.1" | bc) 2> /dev/null
		sed -i -r "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName"),[0-9\.]*$|$fileName,${newPriority:-0}|" \
			"$configDir/priority.csv"
	done <"$configDir/priority.csv"
}

# check for dependencies
[[ ! -x "$(which rsync 2> /dev/null)" ]] && \
    echo "Error: missing dependency 'rsync'" && exit 1
[[ ! -x "$(which sshfs 2> /dev/null)" ]] && \
    echo "Error: missing dependency 'sshfs'" && exit 1
[[ ! -x "$(which inotifywait 2> /dev/null)" ]] && \
    echo "Error: missing dependency 'inotify-tools'" && exit 1
[[ ! -x "$(which systemctl 2> /dev/null)" ]] && \
    echo "Error: missing dependency 'systemd'" && exit 1
[[ ! -x "$(which bc 2> /dev/null)" ]] && \
    echo "Error: missing dependency 'bc'" && exit 1

# parse options
for ((i=1; i<=$#; i++)); do
	# Note: getopt isn't being used here because getopt doesn't allow for
	# parameters to have their own options

	# if parameter is a double dash, stop parsing options
    if [[ "${@:$i:1}" == "--" ]]; then
        break

	# if parameter is multiple short options sharing a hyphen, separate them
	elif [[ "${@:$i:1}" =~ ^-[^-\ ]{2,} ]]; then
		set -- "${@:1:$((i-1))}" $(sed -e 's/\(\w\)/ -\1/g' -e 's/^- //' <<< "${@:$i:1}") "${@:$((i+1))}"

	# if parameter is a long option with an argument separated by an equals
	# sign, replace the equals sign with a space
	elif [[ "${@:$i:1}" =~ ^--[^-\ ] ]]; then
		set -- "${@:1:$((i-1))}" $(sed -e 's/=/ /' <<< "${@:$i:1}") "${@:$((i+1))}"
	fi
done

# read global options
while [[ "$1" =~ ^- ]]; do
	case "$1" in
		--help)
			usage
			exit ;;
		--version)
			echo "retain-sync $version"
			exit ;;
		-q|--quiet)
			exec > /dev/null
			shift ;;
		--)
			shift
			break ;;
		*)
			>&2 echo "Error: unknown option"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1 ;;
	esac
done

# read subcommand
case "$1" in
	'')
		>&2 echo "Error: missing argument"
		>&2 echo "Try 'retain-sync --help' for more information."
		exit 1 ;;
	initialize)
		if [[ -z "$2" ]]; then
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
		fi

		# read options
		while [[ "$2" =~ ^- ]]; do
			case "$2" in
				-e|--exclude)
					optExcludeFile="$3"
					shift 2 ;;
				--)
					shift
					break ;;
				*)
					>&2 echo "Error: unknown option"
					>&2 echo "Try 'retain-sync --help' for more information."
					exit 1 ;;
			esac
		done

		initializeDir "$2" ;;
	sync)
		if [[ -z "$2" ]]; then
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
		fi
		syncDir "$2" ;;
	retrieve)
		if [[ -z "$2" ]]; then
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
		fi
		retrieveDir "$2" ;;
	list-configs)
		listConfigs ;;
	empty-trash)
		if [[ -z "$2" ]]; then
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
		fi
		emptyTrash "$2" ;;
	age)
		if [[ -z "$2" ]]; then
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
		fi
		agePriority "$2" ;;
	*)
		>&2 echo "Error: '$1' is not a valid command"
		>&2 echo "Try 'retain-sync --help' for more information."
		exit 1 ;;
esac
