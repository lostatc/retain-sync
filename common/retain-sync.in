#!/usr/bin/env bash

# Copyright Â© 2016 Garrett Powell <garrett@gpowell.net>
#
# This file is part of retain-sync.
#
# retain-sync is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# retain-sync is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with retain-sync. If not, see <http://www.gnu.org/licenses/>.

# enable extended globbing
shopt -s extglob

# the current version of the program; this is set by the Makefile
version="@VERSION@"

usage() {
	# print a brief usage message; called by the '--help' flag

	cat <<-EOF
		Usage: ${cBR}retain-sync${cN} [${cBG}global_options${cN}] ${cBG}command${cN} [${cBG}command_options${cN}] [${cBG}command_arg${cN}]

		Global options:
		        ${cBR}--help${cN}		Display this usage message and exit.
		        ${cBR}--version${cN}	Print version number and exit.
		    ${cBR}-q${cN}, ${cBR}--quiet${cN}		Suppress all non-error output.

		Commands:
		    ${cBR}initialize${cN} [${cBG}options${cN}] ${cBG}path${cN}
		        Prepare the local directory ${cBG}path${cN} for syncing by moving its contents
		        to the remote directory and generating a configuration for it.
		        ${cBR}-e${cN}, ${cBR}--exclude${cN} ${cBG}file${cN}
		            Get a list of file/directory paths from ${cBG}file${cN} (one per line)
		            that will be excluded from syncing. If ${cBG}file${cN} is '-', then a
		            newline-separated list of file paths will be accepted from stdin.
		        ${cBR}-t${cN}, ${cBR}--template${cN} ${cBG}file${cN}
		            Get settings for the configuration from the template ${cBG}file${cN} instead of
		            prompting the user interactively.
		        ${cBR}-a${cN}, ${cBR}--add-remote${cN}
		            Instead of moving local files to an empty remote directory, start
		            with an existing remote directory and an empty local directory.

		    ${cBR}sync${cN} ${cBG}config${cN}|${cBG}path${cN}
		        Redistribute files between the local and remote directories based on
		        their priority and update the remote directory with any new or deleted
		        files.

		    ${cBR}reset${cN} [${cBG}options${cN}] ${cBG}config${cN}|${cBG}path${cN}
		        Retrieve all files from the remote directory and de-initialize the local
		        directory.
		        ${cBR}-k${cN}, ${cBR}--keep-remote${cN}
		            Copy files from the remote directory to the local one instead of moving
		            them.
		        ${cBR}-n${cN}, ${cBR}--no-retrieve${cN}
		            Don't retrieve files from the remote directory.

		    ${cBR}list-configs${cN}
		        Print a table of all initialized directories and the names of their
		        configurations.

		    ${cBR}empty-trash${cN} ${cBG}config${cN}|${cBG}path${cN}
		        Permanently delete all files in the remote directory that are marked for
		        deletion.
	EOF
}

freezeConfig() {
	# copy config files into memory for parsing and to prevent issues with them
	# being edited during an operation
	excludeFile="$(mktemp)"
	configFile="$(mktemp)"

	[[ -f "$configDir/exclude" ]] && \
		grep -v '^#' "$configDir/exclude" | sed 's|/$||' > "$excludeFile"
	[[ -f "$configDir/config" ]] && \
		cp "$configDir/config" "$configFile"
}

parseConfig() {
	# parse a configuration file and read its contents into variables
	# (see genConfig() for config file format)

	local inputFile="$1"

	# possible values for boolean options (case insensitive)
	local boolValues=("yes" "no")

	# source variables from config
	local configError=0
	local reqVarsTest
	while read -r i; do
		((lineNumber++))

		# line is blank, skip
		[[ "$i" =~ ^$ ]] && continue

		# line is a comment, skip
		[[ "$i" =~ ^# ]] && continue

		# run if line is missing an equals sign
		if ! [[ "$i" =~ = ]]; then
			>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
			((configError++))
			continue
		fi

		# parse option, removing leading/trailing whitespace
		local varName="$(cut -d '=' -f 1 <<< "$i" | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')"
		local varValue="$(cut -d '=' -f 2- <<< "$i" | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')"

		# if option is required, add it to an array to be cross-referenced with the list
		# of all required options
		if echo "$varName" | grep -Fxqf <(printf "%s\n" "${reqVars[@]}"); then
			reqVarsTest+=("$varName")
		fi

		# check if option is recognized
		if ! grep -Fxqf <(printf "%s\n" "${reqVars[@]}" "${optVars[@]}") <<< "$varName"; then
			>&2 echo "Error: line $lineNumber of config file: unrecognized option '$varName'"
			((configError++))
			continue
		fi

		# check if value of boolean option is recognized
		if grep -Fxqf <(printf "%s\n" "${boolVars[@]}") <<< "$varName"; then
			if ! grep -Fxqf <(printf "%s\n" "${boolValues[@]}") <<< "${varValue,,}"; then
				>&2 echo "Error: line $lineNumber of config file: unrecognized value for boolean option"
				((configError++))
				continue
			fi
		fi

		# declare variable unless value is null
		if [[ -n "$varValue" ]]; then
			declare -g "${varName}In"="$varValue"
		fi
	done <"$inputFile"

	# check if all required options were included in config file
	IFS=$'\n'
	reqVarsTest=($(printf "%s\n" "${reqVarsTest[@]}" | sort | uniq))
	local reqVarsMissing=($(printf "%s\n" "${reqVarsTest[@]}" "${reqVars[@]}" | sort | \
		uniq -u))
	unset IFS
	if [[ "${#reqVarsMissing[@]}" -gt 0 ]]; then
		for i in "${reqVarsMissing[@]}"; do
			>&2 echo "Error: missing required option '$i' in config file"
			((configError++))
		done
	fi

	# exit if there were errors in config file
	[[ $configError -ne 0 ]] && exit 1

	uniqueID="$(cut -c 1-8 /etc/machine-id)-$USER-$configName"

	# set default values for non-mandatory options
	sshfsOptions="${sshfsOptionsIn:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}"
	trashDirs=${trashDirsIn:-${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files}
	deleteAlways="${deleteAlwaysIn:-no}"
	syncExtraFiles="${syncExtraFilesIn:-yes}"
	inflatePriority="${inflatePriorityIn:-yes}"
	accountForSize="${accountForSizeIn:-yes}"
	sshOptions=(-o ServerAliveInterval=5 -o ServerAliveCountMax=3 -p "$portIn")

	# format variables, preserving original input

	# apply tilde expansion
	localDir="$(sed "s|^~/|$HOME/|" <<< "$localDirIn")"
	# remove trailing slash
	localDir="${localDir%/}"
	# required for ssh command syntax
	remoteUser="${remoteUserIn:+$remoteUserIn@}"
	remoteHost="$remoteHostIn"
	# treat 'localhost' or '127.0.0.1' as if the user had left the value blank
	[[ "$remoteHost" == "localhost" || \
		"$remoteHost" == "127.0.0.1" ]] && remoteHost=""
	# apply tilde expansion
	remoteDir="$(sed "s|^~/|$HOME/|" <<< "$remoteDirIn")"
	# remove trailing slash
	remoteDir="${remoteDir%/}"
	# convert human-readable format to bytes
	storageLimit="$(sed -r -e 's/KB?/\*1024/' -e 's/MB?/\*1048576/' \
		-e 's/GB?/\*1073741824/' <<< "$storageLimitIn" | bc)"
	# 'nonempty' option required because of '.dest' directory in mountpoint
	# (see bottom of initializeDir())
	sshfsOptions=(-o "$sshfsOptions" -o "nonempty" -p "$portIn")
	IFS=$'\n'
	# convert to an array of directory paths and apply tilde expansion
	trashDirs=($(tr ':' '\n' <<< "$trashDirs" | sed "s|^~/|$HOME/|"))
	unset IFS
	# make input lower-case
	deleteAlways="${deleteAlways,,}"
	syncExtraFiles="${syncExtraFiles,,}"
	inflatePriority="${inflatePriority,,}"
	accountForSize="${accountForSize,,}"
	# this is where local files will be sent and remote files will be retrieved
	if [[ -n "$remoteHost" ]]; then
		destDir="$configDir/mnt/.dest/.."
	else
		destDir="$remoteDir"
	fi

	# escape paths for use in sed substitutions
	localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"
	remoteDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$remoteDir")"
	configDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir")"
	destDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$destDir")"

	# check for additional dependencies
	if [[ -n "$remoteHost" ]]; then
		[[ ! -x "$(which sshfs 2> /dev/null)" ]] && \
			echo "Error: 'sshfs' is required for syncing across machines" && exit 1
	fi
}

readInput() {
	# accept either the name of a valid configuration or the absolute path of a
	# local initialized directory

	if [[ -d "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs/$1" ]]; then
			# parameter is a valid config
			configName="$1"
	elif [[ "$1" =~ ^~?/ ]]; then
		# parameter is an absolute path
		if [[ -f "$1/.retain-sync_init" ]]; then
			# parameter is an initialized directory
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_init")
		elif [[ -f "$1/.retain-sync_part" ]]; then
			# directory initialization was interrupted
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_part")
		else
			>&2 echo "Error: '$1' is not an initialized directory"
			exit 1
		fi
	else
		>&2 echo "Error: '$1' is not a valid configuration or an absolute path"
		exit 1
	fi
	configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs/$configName"

	freezeConfig
	parseConfig "$configFile"
}

fileLock() {
	# open lock file
	exec 9>"$localDir/.retain-sync_lock"
	flock -n 9

	# run if lock file was already open
	if [[ "$?" -ne 0 ]]; then
		>&2 echo "Error: another operation on this configuration is already running"
		exit 1
	fi
}

sshMaster() {
	# initiate a master ssh connection

	# add ControlPath to ssh defaults
	sshOptions+=(-S "$XDG_RUNTIME_DIR/retain-sync/%C.sock")

	# create runtime dir if it doesn't already exist
	mkdir -p "$XDG_RUNTIME_DIR/retain-sync"

	# all subsequent ssh commands (excluding sshfs)  will use this master connection
	# instead of reconnecting each time
	ssh "${sshOptions[@]}" -fNM "$remoteUser$remoteHost"
}

genConfig() {
	# generate a configuration file, prompting the user for unset values

	# the point of the input redirection with /dev/tty is to prevent read from trying
	# to read stdin

	# prompt user for name of config
	if [[ -z "${configName:+x}" ]]; then
		IFS=$'\n'
		while true; do
			read -erp "Enter a name for this configuration: " configName </dev/tty
			if [[ -z "$configName" ]]; then
				>&2 echo "Error: this value may not be blank"
			elif [[ "$configName" =~ [\ ]+ ]]; then
				>&2 echo "Error: this value may not contain spaces"
			elif [[ "$configName" =~ [^0-9A-Za-z_-]+ ]]; then
				>&2 echo "Error: only alphanumeric characters, hyphens and underscores are allowed"
			elif [[ -z "$(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs" -mindepth 1 -maxdepth 1 -type d)" ]]; then
				break
			elif grep -Fxq "$configName" <(basename -a $(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs" -mindepth 1 -maxdepth 1 -type d 2> /dev/null)); then
				>&2 echo "Error: the name '$configName' is already in use"
			else
				break
			fi
		done
		unset IFS
	fi

	# prompt user for hostname of remote machine
	if [[ -z "${remoteHostIn:+x}" ]]; then
		while true; do
			read -erp "Enter the hostname, ip address or domain name of the server (optional): " remoteHostIn </dev/tty
			if [[ "$remoteHostIn" =~ [\ ]+ ]]; then
				>&2 echo "Error: this value may not contain spaces"
			else
				break
			fi
		done
	fi

	[[ "$remoteHostIn" == "localhost" || "$remoteHostIn" == "127.0.0.1" ]] && remoteHostIn=""

	if [[ -n "$remoteHostIn" ]]; then
		# prompt user for user name on remote machine
		if [[ -z "${remoteUserIn:+x}" ]]; then
			while true; do
				read -erp "Enter your user name on the server ($USER): " remoteUserIn </dev/tty
				if [[ "$remoteUserIn" =~ [\ ]+ ]]; then
					>&2 echo "Error: user name may not contain spaces"
				else
					break
				fi
			done
		fi

		# prompt user for port number
		if [[ -z "${portIn:+x}" ]]; then
			while true; do
				read -erp "Enter the port number for the connection: " -i "22" portIn </dev/tty
				if [[ -z "$portIn" ]]; then
					>&2 echo "Error: this value may not be blank"
				elif ! [[ "$portIn" =~ ^[0-9]+$ ]]; then
					>&2 echo "Error: value must be a number in the range 0-65535"
				elif [[ "$portIn" -lt 1 || "$portIn" -gt 65535 ]]; then
					>&2 echo "Error: value must be a number in the range 0-65535"
				else
					break
				fi
			done
		fi
	fi

	# prompt user for remote directory path
	if [[ -z "${remoteDirIn:+x}" ]]; then
		while true; do
			read -erp "Enter the remote directory path: " remoteDirIn </dev/tty
			if [[ -z "$remoteDirIn" ]]; then
				>&2 echo "Error: this value may not be blank"
			elif [[ ! "$remoteDirIn" =~ ^~?/ ]]; then
				>&2 echo "Error: must be an absolute path"
			else
				break
			fi
		done
	fi

	# prompt user for storage limit
	if [[ -z "${storageLimitIn:+x}" ]]; then
		while true; do
			read -erp "Enter the amount of data to keep synced in the local directory (accepts K, M or G): " storageLimitIn </dev/tty
			if [[ ! "$storageLimitIn" =~ ^[0-9]+(K|M|G|KB|MB|GB)$ ]]; then
				>&2 echo "Error: must be a whole number followed by a unit (e.g. 10G)"
			else
				break
			fi
		done
	fi

	# create config directory
	configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs/$configName"
	mkdir -p "$configDir"

	# create config file
	cat <<-EOF > "$configDir/config"
		#
		# retain-sync config
		#

		# local directory to sync
		localDir=$localDir

		# hostname, ip address or domain name of the server (optional)
		remoteHost=$remoteHostIn

		# user name on the server (optional)
		remoteUser=$remoteUserIn

		# port number for the connection (optional)
		port=$portIn

		# remote directory to sync to
		remoteDir=$remoteDirIn

		# amount of data to keep in local directory (accepts K, M or G)
		storageLimit=$storageLimitIn


		# mount options to pass to sshfs
		#sshfsOptions=${sshfsOptionsIn:-reconnect,ServerAliveInterval=5,ServerAliveCountMax=3}

		# colon-separated list of directory paths in which to search for deleted files
		#trashDirs=${trashDirs:-${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files}

		# always delete files from the remote directory when their local counterparts
		# are deleted, even if copies aren't found in the local user's trash
		#deleteAlways=${deleteAlwaysIn:-no}

		# start syncing individual files once no more whole directories can fit within
		# the storage limit
		#syncExtraFiles=${syncExtraFilesIn:-yes}

		# inflate the priority of new local files so that they stick around longer
		#inflatePriority=${inflatePriorityIn:-yes}

		# take file size into account when prioritizing files
		#accountForSize=${accountForSizeIn:-yes}
	EOF

	# run if --template option was given
	if [[ -n "$optConfigFile" ]]; then
		for i in "${optVars[@]}"; do
			# uncomment option if it is uncommented in template file
			if grep -Eq "^[ \t]*$i[ \t]*=" "$optConfigFile"; then
				sed -i "s/^#$i=/$i=/" "$configDir/config"
			fi
		done
	fi
}

initializeDir() {
	# called by the 'initialize' command; see man page for details

	cleanup() {
		# stop ssh master connection
		[[ -n "$remoteHost" ]] && ssh -O exit -S \
			"$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u 9

		# inform user if initialization is interrupted
		if [[ -f "$localDir/.retain-sync_part" ]]; then
			printf "\n%s\n" "Initialization was interrupted."
			echo "Please run 'retain-sync initialize' to complete it or 'retain-sync reset' to cancel it."
		elif ! [[ -f "$localDir/.retain-sync_init" ]]; then
			rm -rf "$configDir"
			rm -f "$localDir/.retain-sync_lock"

			if [[ "$optAddRemote" == "true" ]]; then
				rmdir "$localDir"
			fi
		fi
	}

	# test if parameter is an absolute path
	if [[ "$1" =~ ^~?/ ]]; then
		localDir="${1%/}"
	else
		>&2 echo "Error: must be an absolute path"
		exit 1
	fi

	# check if local directory exists
	if ! [[ -d "$localDir" ]]; then
		if [[ "$optAddRemote" == "true" ]]; then
			mkdir -p "$localDir"
		else
			>&2 echo "Error: the local directory '$localDir' does not exist"
			exit 1
		fi
	fi

	# if --remote option is given, make sure that the local directory is empty
	if [[ "$optAddRemote" == "true" && -n "$(find "$localDir" -mindepth 1)" ]]; then
		>&2 echo "Error: local directory is not empty"
		exit 1
	fi

	# check argument for --exclude option
	if [[ -n "$optExcludeFile" ]]; then
		if [[ "$optExcludeFile" == "-" ]]; then
			# read contents of stdin to array
			mapfile -t excludeInputFiles
		elif [[ -f "$optExcludeFile" ]]; then
			# read contents of exclude input file to array
			mapfile -t excludeInputFiles < "$optExcludeFile"
		else
			# argument is invalid
			>&2 echo "Error: input file for '--exclude' is invalid"
			exit 1
		fi
	fi

	# check argument for --template option
	if [[ -n "$optConfigFile" ]]; then
		if ! [[ -f "$optConfigFile" ]]; then
			# argument is invalid
			>&2 echo "Error: input file for '--template' is invalid"
			exit 1
		fi
	fi

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# don't run if finishing an interrupted initialization
	if [[ ! -f "$localDir/.retain-sync_part" ]]; then
		# check if directory has already been initialized
		if [[ -f "$localDir/.retain-sync_init" ]]; then
			>&2 echo "Error: the specified directory has already been initialized by '$(cat "$localDir/.retain-sync_init")'"
			exit 1
		fi

		# check if directory includes the retain-sync config
		if find "$localDir" -type d | grep -Fxq "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync"; then
			>&2 echo "Error: the specified directory contains retain-sync config files"
			exit 1
		fi

		mkdir -p "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs"

		# check if directory overlaps with another retain-sync configuration
		IFS=$'\n'
		local configDirs=($(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs" \
			-mindepth 1 -maxdepth 1 -type d))
		if [[ "${#configDirs[@]}" -gt 0 ]]; then
			while read -r i; do
				local localDirTest="$(grep "localDir=" "$i/config" | cut -d '=' -f 2-)"
				local localTreeTest=($(find "$localDirTest" -type d))
				local localTree=($(find "$localDir" -type d))
				if [[ -n "$(printf "%s\n" "${localTreeTest[@]}" "${localTree[@]}" | sort | uniq -d)" ]]; then
					>&2 echo "Error: the specified directory overlaps with the configuration '$(basename "$i")'"
					exit 1
				fi
			done < <(printf "%s\n" "${configDirs[@]}")
		fi
		unset IFS

		# read template if one was specified
		if [[ -n "$optConfigFile" ]]; then
			# allow for 'configName' option in template file
			reqVars+=("configName")

			# remove requirement for 'localDir' option in template file because it
			# is specified as a command-line parameter
			IFS=$'\n'
			reqVars=($(printf "%s\n" "${reqVars[@]}" | grep -v "localDir"))
			unset IFS

			# save value of '$localDir' so that it isn't overwritten
			localDirTmp="$localDir"
			parseConfig "$optConfigFile"
			localDir="$localDirTmp"

			configName="$configNameIn"
			configDir="${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs/$configName"

			# undo changes to config file requirements
			IFS=$'\n'
			reqVars=($(printf "%s\n" "${reqVars[@]}" | grep -v "configName"))
			unset IFS
			reqVars+=("localDir")
		fi

		# generate config file
		genConfig

		# This is required becuase genConfig() doesn't set the variables for the
		# non-mandatory config file options, which is necessary so that user-set options
		# aren't overridden when initializing from a template.
		parseConfig "$configDir/config"

		printf "\n"

		# start ssh master connection
		[[ -n "$remoteHost" ]] && sshMaster

		# check if remote directory exists
		if [[ -n "$remoteHost" ]]; then
			if [[ "$optAddRemote" == "true" ]]; then
				if ! ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "[[ -d '$remoteDir' ]]"; then
					>&2 echo "Error: the remote directory '$remoteDir' does not exist"
					exit 1
				fi
			else
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "mkdir -p '$remoteDir'" \
					|| exit 1
			fi
		else
			if [[ "$optAddRemote" == "true" ]]; then
				if ! [[ -d "$remoteDir" ]]; then
					>&2 echo "Error: the remote directory '$remoteDir' does not exist"
					exit 1
				fi
			else
				mkdir -p "$remoteDir"
			fi
		fi

		if ! [[ "$optAddRemote" == "true" ]]; then
			# check if remote directory is empty
			if [[ -n "$remoteHost" ]]; then
				if [[ -n "$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "find '$remoteDir' -mindepth 1")" ]]; then
					>&2 printf "\n%s\n" "Error: remote directory is not empty"
					exit 1
				fi
			else
				if [[ -n "$(find "$remoteDir" -mindepth 1)" ]]; then
					>&2 printf "\n%s\n" "Error: remote directory is not empty"
					exit 1
				fi
			fi
		fi

		# add all local symlinks to the exclude file so they don't get clobbered (this
		# does not include symlinks to directories)
		cat <<-EOF > "$configDir/exclude"
			# This file contains paths to files/directories to exclude from syncing.
			#
			# The root of each file/directory path is anchored to the local initialized
			# directory (see retain-sync(1) for details).
			#
			# All user-created symbolic links in the local initialized directory are added
			# to this file automatically.
		EOF
		find "$localDir" -not -path '*/\.*' -type l | sed -r "s|$localDirEsc||" >> \
			"$configDir/exclude"

		IFS=$'\n'
		local localFiles=($(find "$localDir" -mindepth 1 -not -path '*/\.*' | sed -r "s|$localDirEsc||"))
		unset IFS

		# run if --exclude option was given
		if [[ -n "$optExcludeFile" ]]; then
			for i in "${excludeInputFiles[@]}"; do
				[[ "$i" =~ ^$ ]] && continue	# skip empty line
				[[ "$i" =~ ^# ]] && continue	# skip commented line

				# add leading slash if it doesn't exist
				[[ "$i" =~ ^/ ]] || i="/$i"

				# if it exists in the local sync directory, copy file path from input file
				# to exclude file
				i="${i/"$localDirEsc"/}"
				if grep -Fxqf <(printf "%s\n" "${localFiles[@]}") <<< "${i%/}"; then
					echo "$i" >> "$configDir/exclude"
				fi
			done
		fi

		freezeConfig

		if ! [[ "$optAddRemote" == "true" ]]; then
			# generate file indicating that the initialization process is in progress
			echo "$configName" > "$localDir/.retain-sync_part"
		fi
	else
		echo "Resuming initialization"

		# read config file
		readInput "$1"

		# start ssh master connection
		[[ -n "$remoteHost" ]] && sshMaster

		# create remote directory if it doesn't already exist
		if [[ -n "$remoteHost" ]]; then
			ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "mkdir -p '$remoteDir'" || exit 1
		else
			mkdir -p "$remoteDir"
		fi
	fi

	if ! [[ "$optAddRemote" == "true" ]]; then
		# check if there is enough space on the server
		printf "%s" "Checking space requirement... "
		if [[ -n "$remoteHost" ]]; then
			local remoteSpace=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
				"df -B 1 '$remoteDir'" | tail -n 1 | awk '{print $4}')
		else
			local remoteSpace=$(df -B 1 "$remoteDir" | tail -n 1 | awk '{print $4}')
		fi
		local localSize=$(du -sb "$localDir" | awk '{print $1}')
		if [[ "$localSize" -gt "$remoteSpace" ]]; then
			>&2 printf "\n%s\n" "Error: not enough free space on the server"
			exit 1
		else
			echo "done"
		fi

		# copy local files to the server
		printf "%s" "Copying local files to remote directory... "
		if [[ -n "$remoteHost" ]]; then
			rsync -e "ssh ${sshOptions[*]}" -asHAXS --exclude=".*" \
				--exclude-from="$excludeFile" "$localDir/" \
				"$remoteUser$remoteHost:$remoteDir" || exit 1
		else
			rsync -asHAXS --exclude=".*" --exclude-from="$excludeFile" "$localDir/" \
				"$remoteDir" || exit 1
		fi
		echo "done"
	fi

	if [[ -n "$remoteHost" ]]; then
		# the purpose of this directory is to ensure that any commands that interact
		# with it (e.g. find $configDir/mnt/.dest/..) fail when sshfs isn't mounted
		mkdir -p "$configDir/mnt/.dest"
		chmod 000 "$configDir/mnt/.dest"
	fi

	# mount sshfs
	if [[ -n "$remoteHost" ]]; then
		mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
			"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt"
		if [[ "$?" -ne 0 ]]; then
			>&2 echo "Error: unable to mount remote directory over sshfs"
			exit 1
		fi

		mkdir -p "$configDir/mnt/.dest"
	fi


	# replace local files with symlinks unless local directory is empty
	printf "%s" "Replacing local files with symbolic links... "
	cp -asf "$destDir"/!(.*) "$localDir" 2> /dev/null
	echo "done"

	# create priority.csv file containing a list of all files in the tree followed
	# by a starting priority of zero
	echo "# Editing this file by hand is not recommended." > "$configDir/priority.csv"
	find "$destDir" -not -type d -exec echo '{},0' \; | \
		sed -r "s|$destDirEsc||" >> "$configDir/priority.csv" || exit 1

	# copy 'exclude' file to remote directory for use when the remote directory
	# is shared with other configurations
	mkdir "$destDir/.exclude"
	cat "$excludeFile" > "$destDir/.exclude/$uniqueID"

	# create "init" file used to indicate that the directory has been initialized and
	# what the name of its config is
	if [[ "$optAddRemote" == "true" ]]; then
		echo "$configName" > "$localDir/.retain-sync_init"
	else
		mv "$localDir/.retain-sync_part" "$localDir/.retain-sync_init"
	fi

	# advise user to start/enable the daemon
	printf "\n%s\n" "Run 'systemctl --user start retain-sync@$configName.service' to start the daemon."
	echo "Run 'systemctl --user enable retain-sync@$configName.service' to start the daemon automatically on login."
}

syncDir() {
	# called by the 'sync' command; see man page for details

	cleanup() {
		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u 9

		# delete temp file
		rm -f "$dirPriorityFile"
	}

	# read config file
	readInput "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# get environment variables for ssh-agent that aren't available when retain-sync is
	# run as a systemd service (there has to be a better way to do this)
	[[ -z ${SSH_AGENT_PID+x} ]] && SSH_AGENT_PID="$(pgrep "ssh-agent" | sort -n | \
		head -n 1)"
	[[ -z ${SSH_AUTH_SOCK+x} ]] && SSH_AUTH_SOCK="$(find /tmp -user "$USER" -type s \
		-path "/tmp/ssh-*" -name "agent.*" 2> /dev/null | sort -n | head -n 1)"
	export SSH_AGENT_PID
	export SSH_AUTH_SOCK

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync reset' to cancel it."
		exit 1
	fi

	if [[ -n "$remoteHost" ]]; then
		# umount sshfs if mountpoint is broken
		[[ ! -d "$configDir/mnt" ]] && fusermount -u "$configDir/mnt"

		# mount sshfs if not already mounted
		mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
			"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt"
		if [[ $? -ne 0 ]]; then
			>&2 echo "Error: unable to mount remote directory over sshfs"
			exit 1
		fi
	fi

	printf "%s" "Checking for new files... "

	# copy 'exclude' file to remote directory
	cat "$excludeFile" > "$destDir/.exclude/$uniqueID"

	# read contents of exclude file into an array of file paths
	IFS=$'\n'
	local excludeFiles
	while read -r i; do
		[[ "$i" =~ ^$ ]] && continue # skip line if empty

		[[ -e "$localDir$i" ]] && \
			excludeFiles+=($(find "$localDir$i" -not -path '*/\.*' -not -type d))
	done <"$excludeFile"
	excludeFiles=($(printf "%s\n" "${excludeFiles[@]}" | sort | uniq))
	local excludeFilesRel=($(printf "%s\n" "${excludeFiles[@]}" | sed -r "s|$localDirEsc||"))

	for i in "${excludeFilesRel[@]}"; do
		iEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")"

		if grep -Exq "^$iEsc,[0-9\.]+$" "$configDir/priority.csv"; then
			# remove excluded files from priority.csv
			sed -i -r -e "s|^$iEsc,[0-9\.]+$||" -e '/^$/d' "$configDir/priority.csv"
		fi
	done

	# remove local broken symlinks that aren't in the exclude file
	find "$localDir" -xtype l | grep -Fxvf <(printf "%s\n" "${excludeFiles[@]}") | \
		xargs -d '\n' rm -f

	# get list of files that have been created or removed since last sync operation
	#
	# 1) print list of files/symlinks in local directory that aren't in the exclude
	#	 file (making paths relative)
	# 2) concatenate list of files in priority.csv (making paths relative)
	# 3) remove all repeated entries in the list
	local diffFiles=($(printf "%s\n" "$(find "$localDir" -not -path '*/\.*' -not -type d | \
		grep -Fvxf <(printf "%s\n" "${excludeFiles[@]}") | sed -r "s|$localDirEsc||")" \
		"$(grep -v '^#' "$configDir/priority.csv" | rev | cut -d ',' -f 2- | rev)" | \
		sort | uniq -u))
	unset IFS

	# find highest priority in priority.csv and add 1 to it
	local newPriority="$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 1 | rev | sort -nr | head -n 1 | \
		awk '{print "scale=6; " $0 "+1"}' | bc)" 2> /dev/null

	# go through files that have chaged since the last sync one at a time
	for i in "${diffFiles[@]}"; do
		local iEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< $i)"

		if grep -Exq "^$iEsc,[0-9\.]+$" "$configDir/priority.csv"; then
			# file is no longer present in local directory, remove from priority file
			sed -i -r -e "s|^$iEsc,[0-9\.]+$||" -e '/^$/d' "$configDir/priority.csv"

			if [[ "$deleteAlways" == "no" ]]; then
				# find size of all files in the user's trash if it hasn't already
				# been done
				IFS=$'\n'
				if [[ -z "${trashFiles+x}" ]]; then
					local trashFiles=($(find "${trashDirs[@]}" \
						-not -type d -not -type l | xargs -d '\n' du -b))
					local trashSizes=($(printf "%s\n" "${trashFiles[@]}" | cut -f 1 | \
						sort | uniq))
				fi

				# find size of current file and compare it to files in trash
				fileSize=$(du -b "$destDir$i" | cut -f 1)
				local dupSize="$(printf "%s\n" "${trashSizes[@]}" "$fileSize" | sort | uniq -d)"

				if [[ -n "$dupSize" ]]; then
					# current file is the same size as at least one file in the trash
					# directory

					# double-check by comparing checksums
					local trashSums=($(awk '$1 == "'$dupSize'"' <(printf "%s\n" \
						"${trashFiles[@]}") | cut -f '2-' | xargs -d '\n' md5sum | \
						cut -c 1-32 | sort | uniq))
					local fileSum="$(md5sum "$destDir$i" | cut -c 1-32)"

					if [[ -n "$(printf "%s\n" "${trashSums[@]}" "$fileSum" | sort | uniq -d)" ]]; then
						# file is in trash, delete corresponding file on the server
						rm "$destDir$i" || exit 1
					else
						# file is not in trash, mark corresponding file on the server for deletion
						mv "$destDir$i" \
							"$destDir$(dirname "$i")/.$(basename "$i").trash" || exit 1
					fi
				else
					# file is not in trash, mark corresponding file on the server for deletion
					mv "$destDir$i" \
						"$destDir$(dirname "$i")/.$(basename "$i").trash" || exit 1
				fi
				unset IFS
			else
				# $deleteAlways is set to 'yes', delete corresponding file on the server
				rm "$destDir$i" || exit 1
			fi
		else
			# new file
			if [[ -L "$localDir$i" ]]; then
				# file is a symlink, add to exclude file
				echo "$i" | tee -a "$excludeFile" >> "$configDir/exclude"
			else
				# file is not a symlink, add to priority.csv
				if [[ "$inflatePriority" == "yes" ]]; then
					# set priority so that it's at the top
					echo "$i,${newPriority:-0}" >> "$configDir/priority.csv"
				else
					# set priority to zero
					echo "$i,0" >> "$configDir/priority.csv"
				fi

				# total size of all new files
				((newFilesSize+="$(du -b "$localDir$i" | awk '{print $1}')"))
			fi
		fi
	done

	# delete broken symlinks in local directory
	find "$localDir" -xtype l -exec rm '{}' \;

	# exit if priority.csv is empty
	if ! grep -vq '^#' "$configDir/priority.csv"; then
		echo "Local directory is empty. There is nothing else to do."
		exit 0
	fi

	# check if there's enough space on the server for the new files
	local remoteSpace=$(df -B 1 "$destDir" | tail -n 1 | awk '{print $4}') || \
		exit 1
	if [[ "$newFilesSize" -gt "$remoteSpace" ]]; then
		>&2 printf "\n%s\n" "Error: not enough free space on the server"
		exit 1
	fi

	# upload new files and files that have changed since the last sync
	rsync -aHAXSu --exclude-from="$excludeFile" --exclude=".*" --safe-links \
		"$localDir/" "$destDir" || exit 1

	# update any excluded files in the remote directory
	rsync -arHAXS --existing --files-from="$excludeFile" --safe-links \
		"$localDir/" "$destDir" || exit 1

	echo "done"

	printf "%s" "Sorting directories by priority... "

	# create directory priority file containing a list of all directories in the
	# tree
	local dirPriorityFile="$(mktemp)"
	find "$destDir" -mindepth 1 -not -name ".*" -type d | sed -r "s|$destDirEsc||" | \
		grep -Fxvf "$excludeFile" > "$dirPriorityFile" || exit 1

	# read directory priority file line-by-line
	while read -r i; do
		local iEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")"

		# remove directories from directory priority file if they're not found in
		# priority.csv
		if ! grep -Eq "^$iEsc" "$configDir/priority.csv"; then
			sed -i -r -e "s|^$iEsc$||" -e "/^$/d" "$dirPriorityFile"
		fi

		# total the priorities of all the files in each directory to get the
		# directory priority
		local dirPriority=$(grep -v '^#' "$configDir/priority.csv" | grep -E "^$iEsc/" | rev | \
			cut -d ',' -f 1 | rev | tr '\n' '+' | sed 's/\+$/\n/' | \
			awk '{print "scale=6; " $0}'| bc) 2> /dev/null

		# get the size of the directory in bytes
		local dirSize="$(du -sb "$destDir$i" | awk '{print $1}')" || exit 1

		# set minimum dir size of 16 bytes to perclude a "divide by zero"
		# error with bc
		[[ "$dirSize" -lt 16 ]] && dirSize=16

		# adjust directory priority for the size of the directory
		# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
		# numbers easier to work with
		if [[ "$accountForSize" == "no" ]]; then
			dirPriority="${dirPriority:-0}"
		else
			dirPriority=$(echo "scale=6; ${dirPriority:-0}/($dirSize/10485760)" | bc)
		fi

		# write directory priority to file
		sed -i -r "s|^$iEsc$|$i,$dirPriority|" \
			"$dirPriorityFile"
	done <"$dirPriorityFile"

	# sort directory priority file and remove priorities, leaving just file paths
	awk -F ',' '{print $NF,$0}' "$dirPriorityFile" | sort -rn | \
		cut -d ' ' -f 2- > "$dirPriorityFile.swp"
	mv "$dirPriorityFile.swp" "$dirPriorityFile"
	sed -i -r 's/,[0-9\.]+$//' "$dirPriorityFile"

	# cut down the directory priority file to only the list of directories that can be
	# stored locally without exceeding the storage limit
	local dirPriorityTree
	while true; do
		local syncSize=0

		while read -r i; do
			dirSize="$(du -sb "$destDir$i" | awk '{print $1}')" || exit 1

			if [[ "$dirSize" -gt $storageLimit ]]; then
				# current directory alone is larger than the storage limit, remove from
				# directory priority file
				grep -Fv "$i" "$dirPriorityFile" > "$dirPriorityFile.swp"
				mv "$dirPriorityFile.swp" "$dirPriorityFile"
			else
				# get size of current directory in bytes and add it to the total
				# size of the list
				((syncSize+=dirSize))

				if [[ "$syncSize" -gt $storageLimit ]]; then
					# total list size has exceeded the storage limit
					if ! grep -Fqxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile"; then
						# none of the directories in the list have subdirectories in
						# the list, remove current directory from the directory
						# priority file because it is too large to fit within the
						# storage limit
						grep -Fv "$i" "$dirPriorityFile" > "$dirPriorityFile.swp"
						mv "$dirPriorityFile.swp" "$dirPriorityFile"

						((syncSize-=dirSize))
					else
						break
					fi
				else
					# total list size is still within the storage limit

					dirPriorityTree+=($(find "$destDir$i" -mindepth 1 -type d | \
						sed -r "s|$destDirEsc||")) || exit 1

					# check if the while loop has reached the last line of the directory
					# priority file
					if [[ "$(tail -n 1 "$dirPriorityFile")" == "$i" ]]; then
						# the list is complete, break out of loops
						break 2
					fi
				fi
			fi
		done <"$dirPriorityFile"

		# break if file is empty
		[[ ! -s "$dirPriorityFile" ]] && break

		# remove subdirectories of directories in the list from the directory priority
		# file
		grep -Fvxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile" > "$dirPriorityFile.swp"
		mv "$dirPriorityFile.swp" "$dirPriorityFile"
	done
	echo "done"

	# get list of individual files that aren't included in the directory priority file
	printf "%s" "Sorting remaining files by priority... "
	IFS=$'\n'
	local noSyncFiles
	noSyncFiles=($(find "$destDir" -not -name '.*.trash' -not -type d | \
		sed -r "s|$destDirEsc||" | grep -Fxvf "$excludeFile")) || exit 1
	while read -r i; do
		noSyncFiles+=($(find "$destDir$i" -not -name '.*.trash' -not \
			-type d | sed -r "s|$destDirEsc||")) || exit 1
	done <"$dirPriorityFile"
	noSyncFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sort | uniq -u))

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# from that list, get list of individual files that can fill the remaining space
		# until the storage limit is reached

		local noSyncSorted
		for i in "${noSyncFiles[@]}"; do
			# search for line containing complete file name in priority file
			noSyncSorted+=($(grep -Ex "^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i"),[0-9\.]+$" \
				"$configDir/priority.csv"))
		done

		# adjust priority for file size
		if ! [[ "$accountForSize" == "no" ]]; then
			for i in "${!noSyncSorted[@]}"; do
				local currentFile="$(rev <<< "${noSyncSorted[$i]}" | cut -d ',' -f 2- | rev)"
				local currentFileSize=$(du -sb "$destDir$currentFile" | \
					awk '{print $1}') || exit 1

				# set minimum file size of 16 bytes to perclude a "divide by zero"
				# error with bc
				if [[ "$currentFileSize" -lt 16 ]]; then
					currentFileSize=16
				fi

				# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
				# numbers easier to work with
				local adjustedPriority=$(echo "scale=6; $(rev <<< "${noSyncSorted[$i]}" | \
					cut -d ',' -f 1 | rev)/($currentFileSize/10485760)" | bc)
				noSyncSorted[$i]="$(sed "s/,[0-9\.]+$/,$adjustedPriority/" <<< \
					"${noSyncSorted[$i]}")"
			done
		fi

		# sort files by priority
		noSyncSorted=($(printf "%s\n" "${noSyncSorted[@]}" | awk -F ',' '{print $NF,$0}' | \
			sort -rn | cut -d ' ' -f 2- | rev | cut -d ',' -f 2- | rev))
		unset IFS

		local extraFiles
		for i in "${noSyncSorted[@]}"; do
			currentFileSize=$(du -sb "$destDir$i" | \
				awk '{print $1}') || exit 1

			# get size of current file in bytes and add it to the total size
			((syncSize+=currentFileSize))

			# check if the total size of the list has exceeded the storage limit
			if [[ "$syncSize" -gt "$storageLimit" ]]; then
				# current file is too big, skip to next one
				((syncSize-=currentFileSize))
			else
				# add current file to the extra files list
				extraFiles+=("$i")
			fi
		done
	fi

	# get list of individual files to remove and change their path context
	IFS=$'\n'
	if [[ "$syncExtraFiles" == "yes" ]]; then
		local rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" "${extraFiles[@]}" | \
			sort | uniq -u | sed "s|^|$localDir|"))
	else
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sed "s|^|$localDir|"))
	fi
	unset IFS
	echo "done"

	# remove files that aren't in the directory priority file or the extra files list
	printf "%s" "Removing unused files... "
	printf "%s\n" "${rmFiles[@]}" | xargs -d '\n' rm -f

	# put a temporary file in each local empty directory to prevent them from
	# being deleted later
	find "$localDir" -mindepth 1 -not -path "*/\.*" -type d -empty -exec \
		touch "{}/.rs-hold" \; 2> /dev/null

	# replace missing files with symlinks
	cp -asn "$destDir"/!(.*) "$localDir" &> /dev/null

	# remove any empty directories that were copied from the remote directory
	# (directories that contain only '.trash' files)
	find "$localDir" -mindepth 1 -not -path "*/\.*" -type d -empty -delete

	# remove temporary files
	find "$localDir" -name ".rs-hold" -type f -empty -delete

	echo "done"

	if [[ -n "$remoteHost" ]]; then
		printf "%s" "Downloading new files... "
	else
		printf "%s" "Importing new files... "
	fi

	# get list of local files that aren't in priority.csv
	#
	# 1) print list of files/symlinks in local directory that aren't hidden
	# 2) filter out files that are in the exclude file (making paths relative)
	# 3) filter out files that are in priority.csv
	IFS=$'\n'
	local newFiles=($(find "$localDir" -not -path '*/\.*' -not -type d | \
		sed -r "s|$localDirEsc||" | grep -Fvxf "$excludeFile" | \
		grep -Fvxf <(grep -v '^#' "$configDir/priority.csv" | rev | cut -d ',' -f 2- | rev)))
	unset IFS

	# add new files to priority.csv (for files that were added to the remote
	# directory since the last sync)
	for i in "${newFiles[@]}"; do
		if [[ "$inflatePriority" == "yes" ]]; then
			echo "$i,${newPriority:-0}" >> "$configDir/priority.csv"
		else
			echo "$i,0" >> "$configDir/priority.csv"
		fi
	done

	while read -r i; do
		# copy excluded file to local directory if it isn't already there
		#
		# if file has been excluded by each configuration that shares this
		# remote directory, remove the file from the remote directory
		if [[ -e "$destDir$i" ]]; then
			local numExOccurrences=$(grep -FRl "$i" "$destDir/.exclude/" | wc -l)
			local numExFiles=$(find "$destDir/.exclude/" -mindepth 1 | wc -l)
			if [[ $numExOccurrences -eq $numExFiles ]]; then
				rsync -aHAXS --remove-source-files --ignore-missing-args \
					"$destDir$i" "$localDir" || exit 1
				find "$destDir$i" -type d -empty -delete
			else
				rsync -aHAXS --ignore-missing-args "$destDir$i" "$localDir" || exit 1
			fi
		fi
	done < "$excludeFile"

	# find file paths in directory priority file
	local downloadFiles
	IFS=$'\n'
	while read -r i; do
		downloadFiles+=($(find "$destDir$i" -not -type d -not -name \
			'.*.trash' | sed -r "s|$destDirEsc||")) || exit 1
	done <"$dirPriorityFile"
	unset IFS

	# download directories that are in the directory priority file but not stored
	# locally
	printf "%s\n" "${downloadFiles[@]}" | rsync -asHAXS --files-from=- \
		--exclude-from="$excludeFile" "$destDir/" "$localDir" || \
		exit 1

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# fill the remaining space with the highest-priority individual files that
		# haven't already been downloaded
		printf "%s\n" "${extraFiles[@]}" | rsync -asHAXS --files-from=- \
			"$destDir/" "$localDir" || exit 1
	fi
	echo "done"
}

resetDir() {
	# called by the 'reset' command; see man page for details

	cleanup() {
		# stop ssh master connection
		[[ -n "$remoteHost" ]] && ssh -O exit -S \
			"$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readInput "$1"

	# lock this configuration
	fileLock

	# check if systemd service is running
	systemctl --user status "retain-sync@$configName.service" &> /dev/null
	if [[ "$?" -eq 0 ]]; then
		>&2 echo "Error: retain-sync@$configName.service is running"
		echo "Please stop and disable the service before proceeding."
		exit 1
	fi

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	[[ -n "$remoteHost" ]] && sshMaster

	# check if there is enough free space on the local machine
	printf "%s" "Checking space requirement... "
	if [[ -n "$remoteHost" ]]; then
		local remoteSize=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
			"du -sb '$remoteDir'" | awk '{print $1}') || exit 1
	else
		remoteSize=$(du -sb "$remoteDir" | awk '{print $1}')
	fi
	local localSpace=$(df -B 1 "$localDir" | tail -n 1 | awk '{print $4}')
	if [[ "$remoteSize" -gt "$localSpace" ]]; then
		# not enough space
		>&2 printf "\n%s\n" "Error: not enough free space on this machine to reset '$configName'"
		exit 1
	else
		echo "done"
	fi

	# read contents of exclude file into an array of file paths
	printf "%s" "Removing symbolic links from local directory... "
	local excludeFiles
	while read -r i; do
		i="$localDir$i"
		[[ -a "$i" ]] && \
			excludeFiles+=($(find "$i" -not -path '*/\.*' -not -type d))
	done < "$excludeFile"

	# remove symlinks that aren't in the exclude file from the local directory
	find "$localDir" -not -path '*/\.*' -type l | \
		grep -Fxvf <(printf "%s\n" "${excludeFiles[@]}") | \
		xargs -d '\n' rm -f && echo "done"

	if [[ "$optKeepRemote" == "true" && "$optNoRetrieve" != "true" ]]; then
		# copy files from remote directory back to local directory
		printf "%s" "Copying remote files to local directory... "
		if [[ -n "$remoteHost" ]]; then
			rsync -e "ssh ${sshOptions[*]}" -asHAXS \
				"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1
		else
			rsync -asHAXS "$remoteDir/" "$localDir" || exit 1
		fi
		echo "done"
	elif [[ "$optNoRetrieve" != "true" ]]; then
		# move files from remote directory back to local directory
		printf "%s" "Moving remote files to local directory... "
		if [[ -n "$remoteHost" ]]; then
			rsync -e "ssh ${sshOptions[*]}" -asHAXS --remove-source-files \
				"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1
		else
			rsync -asHAXS --remove-source-files "$remoteDir/" "$localDir" || exit 1
		fi

		# remove empty directories
		if [[ -n "$remoteHost" ]]; then
			ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
				"find '$remoteDir' -type d -empty -delete" || exit 1
		else
			find "$remoteDir" -type d -empty -delete
		fi
		echo "done"
	fi

	printf "%s" "Cleaning up... "

	if [[ -n "$remoteHost" ]]; then
		# unmount sshfs
		mkdir -p "$configDir/mnt/.dest" 2> /dev/null
		if mountpoint -q "$configDir/mnt" || [[ ! -d "$configDir/mnt" ]]; then
			fusermount -u "$configDir/mnt" || exit 1
		fi

		chmod 700 "$configDir/mnt/.dest"
	fi

	# remove init file, lock file and config directory
	rm -f "$localDir/.retain-sync_init" "$localDir/.retain-sync_part" \
		"$localDir/.retain-sync_lock"
	rm -r "$configDir"
	echo "done"
}

listConfigs() {
	# called by the 'list-configs' command; see man page for details

	# get a list of directory paths that have been initialized and the names of their
	# configurations
	local configName
	local localDir
	IFS=$'\n'
	while read -r i; do
		configName+=($(basename "$i"))
		localDir+=($(grep "localDir=" "$i/config" | cut -d '=' -f 2-))
	done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/configs" \
		-mindepth 1 -maxdepth 1 -type d 2> /dev/null)
	unset IFS

	if [[ "${#configName[@]}" -eq 0 ]]; then
		printf "\n%s\n\n" "-- No configs --"
		return 0
	fi

	# find length of longest configuration name or "Configuration"
	local configLength=$(printf "%s\n" "${configName[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	configLength=$((configLength>13 ? configLength:13))

	# find length of longest local directory path or "Local directory"
	local dirLength=$(printf "%s\n" "${localDir[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	dirLength=$((dirLength>15 ? dirLength:15))

	# print header
	printf "%-${configLength}s | %-s\n" "Configuration" "Local directory"

	# print horizontal separator
	printf '%.0s-' $(seq 1 $((configLength+1)))
	printf '+'
	printf '%.0s-' $(seq 1 $((dirLength+1)))

	# print rest of table
	paste -d ' ' <(printf "\n%-${configLength}s |" "${configName[@]}") <(printf "\n%-s" "${localDir[@]}")
}

emptyTrash() {
	# called by the 'empty-trash' command; see man page for details

	cleanup() {
		# stop ssh master connection
		[[ -n "$remoteHost" ]] && ssh -O exit -S \
			"$XDG_RUNTIME_DIR"/retain-sync/%C.sock "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readInput "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	[[ -n "$remoteHost" ]] && sshMaster

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync reset' to cancel it."
		exit 1
	fi

	# get list of files marked for deletion
	IFS=$'\n'
	if [[ -n "$remoteHost" ]]; then
		local trashFiles=($(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
			"find '$remoteDir' -not -type d -name '.*.trash'")) || exit 1
	else
		trashFiles=($(find "$remoteDir" -not -type d -name '.*.trash'))
	fi
	unset IFS

	# delete files if there are any
	if [[ "${#trashFiles[@]}" -gt 0 ]]; then
		printf "%s" "Emptying trash... "
		if [[ -n "$remoteHost" ]]; then
			printf "%s\n" "${trashFiles[@]}" | ssh "${sshOptions[@]}" \
				"$remoteUser$remoteHost" "xargs -d '\n' rm"
		else
			printf "%s\n" "${trashFiles[@]}" | xargs -d '\n' rm
		fi
		echo "done"
		echo "${#trashFiles[@]} files deleted"
	else
		echo "No files to delete"
	fi
}

agePriority() {
	# adjust the priority of all files for time; called by the undocumented 'age' command

	# read config file
	readInput "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		echo "Please run 'retain-sync initialize' to complete it or 'retain-sync reset' to cancel it."
		exit 1
	fi

	# divide the priority of every file by 1.05
	while read -r i; do
		local fileName="$(rev <<< "$i" | cut -d ',' -f 2- | rev)"
		local newPriority=$(echo "scale=6; $(rev <<< "$i" | cut -d ',' -f 1 | rev)/1.05" | bc) 2> /dev/null
		sed -i -r "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName"),[0-9\.]+$|$fileName,${newPriority:-0}|" \
			"$configDir/priority.csv"
	done <"$configDir/priority.csv"
}

main() {
	# check for dependencies
	[[ ! -x "$(which rsync 2> /dev/null)" ]] && \
		echo "Error: missing dependency 'rsync'" && exit 1
	[[ ! -x "$(which inotifywait 2> /dev/null)" ]] && \
		echo "Error: missing dependency 'inotify-tools'" && exit 1
	[[ ! -x "$(which systemctl 2> /dev/null)" ]] && \
		echo "Error: missing dependency 'systemd'" && exit 1
	[[ ! -x "$(which bc 2> /dev/null)" ]] && \
		echo "Error: missing dependency 'bc'" && exit 1

	# This is where options are defined that are recognized in the config file.
	# When the config file is parsed, option values are declared as variables that
	# have the same name with 'In' appended to the end of them. The option
	# "localDir" is declared as "localDirIn".

	# mandatory options
	mapfile -t reqVars <<-EOF
		localDir
		remoteUser
		remoteHost
		port
		remoteDir
		storageLimit
	EOF

	# non-mandatory options
	mapfile -t optVars <<-EOF
		sshfsOptions
		trashDirs
		deleteAlways
		syncExtraFiles
		inflatePriority
		accountForSize
	EOF

	# boolean options
	mapfile -t boolVars <<-EOF
		deleteAlways
		syncExtraFiles
		inflatePriority
		accountForSize
	EOF

	# enable colored output unless stdout is being redirected
	if [[ -t 1 ]]; then
		# set colors for colored output
		cBG="$(tput bold)$(tput setaf 2)"	# bold green
		cBR="$(tput bold)$(tput setaf 1)"	# bold red
		cN="$(tput sgr0)"					# normal
	fi

	# parse options
	for ((i=1; i<=$#; i++)); do
		# Note: getopt isn't being used here because getopt doesn't allow for
		# parameters to have their own options

		# if parameter is a double dash, stop parsing options
		if [[ "${@:$i:1}" == "--" ]]; then
			break

		# if parameter is multiple short options sharing a hyphen, separate them
		elif [[ "${@:$i:1}" =~ ^-[^-\ ]{2,} ]]; then
			set -- "${@:1:$((i-1))}" $(sed -e 's/\(\w\)/ -\1/g' -e 's/^- //' <<< "${@:$i:1}") "${@:$((i+1))}"

		# if parameter is a long option with an argument separated by an equals
		# sign, replace the equals sign with a space
		elif [[ "${@:$i:1}" =~ ^--[^-\ ] ]]; then
			set -- "${@:1:$((i-1))}" $(sed -e 's/=/ /' <<< "${@:$i:1}") "${@:$((i+1))}"
		fi
	done

	# read global options
	while [[ "$1" =~ ^- ]]; do
		case "$1" in
			--help)
				usage
				exit ;;
			--version)
				echo "retain-sync $version"
				exit ;;
			-q|--quiet)
				exec > /dev/null
				shift ;;
			--)
				shift
				break ;;
			*)
				>&2 echo "Error: unknown option"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1 ;;
		esac
	done

	# read command
	case "$1" in
		'')
			>&2 echo "Error: missing argument"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
			;;
		init|initialize)
			if [[ -z "$2" ]]; then
				>&2 echo "Error: missing argument"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1
			fi

			# read options
			while [[ "$2" =~ ^- ]]; do
				case "$2" in
					-e|--exclude)
						optExcludeFile="$3"
						shift 2
						;;
					-t|--template)
						optConfigFile="$3"
						shift 2
						;;
					-a|--add-remote)
						optAddRemote="true"
						shift
						;;
					--)
						shift
						break
						;;
					*)
						>&2 echo "Error: unknown option '$2'"
						>&2 echo "Try 'retain-sync --help' for more information."
						exit 1
						;;
				esac
			done

			initializeDir "$2"
			;;
		sync)
			if [[ -z "$2" ]]; then
				>&2 echo "Error: missing argument"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1
			fi

			syncDir "$2"
			;;
		reset)
			if [[ -z "$2" ]]; then
				>&2 echo "Error: missing argument"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1
			fi

			# read options
			while [[ "$2" =~ ^- ]]; do
				case "$2" in
					-k|--keep-remote)
						optKeepRemote="true"
						shift 1
						;;
					-n|--no-retrieve)
						optNoRetrieve="true"
						shift 1
						;;
					--)
						shift
						break
						;;
					*)
						>&2 echo "Error: unknown option '$2'"
						>&2 echo "Try 'retain-sync --help' for more information."
						exit 1
						;;
				esac
			done

			resetDir "$2"
			;;
		list-configs)
			listConfigs
			;;
		empty-trash)
			if [[ -z "$2" ]]; then
				>&2 echo "Error: missing argument"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1
			fi
			emptyTrash "$2"
			;;
		age)
			if [[ -z "$2" ]]; then
				>&2 echo "Error: missing argument"
				>&2 echo "Try 'retain-sync --help' for more information."
				exit 1
			fi
			agePriority "$2"
			;;
		*)
			>&2 echo "Error: '$1' is not a valid command"
			>&2 echo "Try 'retain-sync --help' for more information."
			exit 1
			;;
	esac
}

main "$@"
