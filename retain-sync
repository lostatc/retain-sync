#!/usr/bin/env bash

printHelp() {
	echo "help"
}

readConfig() {
	# accepts either the name of a configuration or the absolute path of a local
	# sync directory
	if [[ -d "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$1" ]]; then
			# parameter is a valid config
			configName="$1"
	elif [[ "$1" =~ ^~?/ ]]; then
		# parameter is an absolute path
		if [[ -f "$1/.retain-sync_init" ]]; then
			# parameter is an initialized directory
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_init")
		elif [[ -f "$1/.retain-sync_part" ]]; then
			# directory initialization was interrupted
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_part")
		else
			printf "Error: \'$1\' is not an initialized directory\n"
			exit 1
		fi
	else
		printf "Error: \'$1\' is not a valid configuration or an absolute path\n"
		exit 1
	fi
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName

	# source variables from config
	configError=0
	while read -r i; do
		((lineNumber++))

		# line is blank, skip
		[[ "$i" =~ ^$ ]] && continue

		# line is a comment, skip
		[[ "$i" =~ ^# ]] && continue

		# run if line is missing an equals sign
		if ! [[ "$i" =~ = ]]; then
			echo "Error: line $lineNumber of config file: unrecognized syntax"
			((configError++))
		fi

		# parse option, removing leading/trailing whitespace
		varName="$(echo "$i" | cut -d '=' -f 1 | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"
		varValue="$(echo "$i" | cut -d '=' -f 2- | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')"

		# run if option is unrecognized
		if ! echo "$varName" | grep -qFf <(cat <<-EOF
			localDir
			remoteUser
			remoteHost
			remoteDir
			storageLimit
			sshfsOptions
			deleteAlways
			syncExtraFiles
		EOF
		); then
			printf "Error: line $lineNumber of config file: unrecognized option \'$varName\'\n"
			((configError++))
		fi

		# declare variable
		declare -g "$varName"="$varValue"
	done <"$configDir/config"

	# exit if there were errors in config file
	[[ ! $configError -ne 0 ]] || exit 1

	# format variables
	localDir="${localDir%/}"
	remoteDir="${remoteDir%/}"
	remoteUser="${remoteUser:+$remoteUser@}"
	sshfsOptions=(-o "$sshfsOptions")

	# set defaults
	sshOptions=(-o ServerAliveInterval=7 -o ServerAliveCountMax=3)
}

fileLock() {
	# open lock file
	exec {lockFD}>"$localDir/.retain-sync_lock"
	flock -n $lockFD

	# run if lock file was already open
	if [[ $? -ne 0 ]]; then
		echo "Error: another operation on this configuration is already running"
		exit 1
	fi
}

sshMaster() {
	# add ControlPath to ssh defaults
	sshOptions+=(-S "$XDG_RUNTIME_DIR/retain-sync/%C.socket")

	# create runtime dir if it doesn't already exist
	mkdir -p "$XDG_RUNTIME_DIR/retain-sync"

	# all subsequent ssh commands (excluding sshfs)  will use this master connection
	# instead of reconnecting each time
	coproc sshMaster { ssh "${sshOptions[@]}" -NM "$remoteUser$remoteHost" 2>&1; } || exit 1

	# open file descriptor with stdout of ssh master command
	exec {sshFD}<&${sshMaster[0]}

	# suppress certain output from ssh master command
	while read -ru $sshFD i; do
		if ! echo "$i" | grep -qEf <(cat <<-EOF
			ControlSocket .* already exists, disabling multiplexing
		EOF
		); then
			echo "$i"
		fi
	done &
}

genConfig() {
	# prompt user for name of config
	while true; do
		read -erp "Enter a name for this configuration: " configName
		configName="$(echo "$configName" | sed -r 's/(^|[^\\])[\"'\'']/\1/g')"
		if [[ -z "$configName" ]]; then
			echo "Error: this value may not be blank"
		elif [[ "$configName" =~ [\ ]+ ]]; then
			echo "Error: this value may not contain spaces"
		elif [[ "$configName" =~ [^0-9A-Za-z_-]+ ]]; then
			echo "Error: only alphanumeric characters, hyphens and underscores are allowed"
		else
			break
		fi
	done

	# prompt user for user name on remote machine
	while true; do
		read -erp "Enter your user name on the remote machine (empty to use local user name): " remoteUser
		remoteUser="$(echo "$remoteUser" | sed -r 's/(^|[^\\])[\"'\'']/\1/g')"
		if [[ "$remoteUser" =~ [\ ]+ ]]; then
			echo "Error: user name may not contain spaces"
		else
			break
		fi
	done

	# prompt user for hostname of remote machine
	while true; do
		read -erp "Enter the hostname, ip address or domain name of the remote machine: " remoteHost
		remoteHost="$(echo "$remoteHost" | sed -r 's/(^|[^\\])[\"'\'']/\1/g')"
		if [[ -z "$remoteHost" ]]; then
			echo "Error: this value may not be blank"
		elif [[ "$remoteHost" =~ [\ ]+ ]]; then
			echo "Error: hostname may not contain spaces"
		else
			break
		fi
	done

	# prompt user for directory to sync to on remote machine
	while true; do
		read -erp "Enter the directory to sync to on the remote machine: " remoteDir
		remoteDir="$(echo "$remoteDir" | sed -r 's/(^|[^\\])[\"'\'']/\1/g')"
		if [[ -z "$remoteDir" ]]; then
			echo "Error: this value may not be blank"
		elif [[ ! "$remoteDir" =~ ^/ ]]; then
			echo "Error: must be an absolute path"
		else
			break
		fi
	done

	# prompt user for storage limit
	while true; do
		read -erp "Enter the amount of data to keep synced locally to this machine (accepts K, M or G): " storageLimit
		storageLimit="$(echo "$storageLimit" | sed -r 's/(^|[^\\])[\"'\'']/\1/g')"
		if [[ ! "$storageLimit" =~ [0-9]+[KMG] ]]; then
			echo "Error: must be a whole number followed by a unit (e.g. 10G)"
		else
			break
		fi
	done

	# set default options
	sshfsOptions="reconnect,ServerAliveInterval=7,ServerAliveCountMax=3"
	deleteAlways="no"
	syncExtraFiles="yes"

	# create config directory
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName
	mkdir "$configDir"

	# create config file
	cat <<-EOF > "$configDir/config"
		#
		# retain-sync config
		#

		# directory to sync on local machine
		localDir=$localDir

		# user name on remote machine (optional)
		remoteUser=$remoteUser

		# hostname, ip address or domain name of remote machine
		remoteHost=$remoteHost

		# directory to sync to on remote machine
		remoteDir=$remoteDir

		# amount of data to keep on local machine (accepts K, M or G)
		storageLimit=$storageLimit

		#-------------------------------------------------------------------------------

		# mount options to pass to sshfs
		sshfsOptions=$sshfsOptions

		# always delete files from the server when their local counterparts are deleted
		deleteAlways=$deleteAlways

		# start syncing individual files once no more whole directories can fit within
		# the storage limit
		syncExtraFiles=$syncExtraFiles
	EOF
}

initializeDir() {
	# function accepts the absolute path of a local directory as a parameter

	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u $lockFD

		# inform user if initialization is interrupted
		if [[ -f "$localDir/.retain-sync_part" ]]; then
			printf "\nInitialization was interrupted.\n"
			printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		fi
	}

	# test if parameter is an absolute path
	if [[ "$1" =~ ^~?/ ]]; then
		# is an absolute path
		localDir="${1%/}" # remove trailing slash
	else
		# not an absolute path
		echo "Error: must be an absolute path"
		exit 1
	fi

	# check if local directory exists
	if ! [[ -d "$1" ]]; then
		printf "Error: no such directory \'$localDir\'\n"
		exit 1
	fi

	# check if exclude input file is a valid file
	if ! [[ -f "$optExcludeFile" ]]; then
		echo "Error: input file is invalid"
		exit 1
	fi

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# don't run if finishing an interrupted initialization
	if [[ ! -f "$localDir/.retain-sync_part" ]]; then
		# check if directory has already been initialized
		[[ -f "$localDir/.retain-sync_init" ]] && \
			printf "Error: the specified directory directory has already been initialized by \'$(cat \
			"$localDir/.retain-sync_init")\'.\n" && exit 1

		# check if directory includes the retain-sync config
		if find "$localDir" -type d | grep -q "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync"; then
			echo "Error: the specified directory contains retain-sync config files"
			exit 1
		fi

		# check if directory overlaps with another retain-sync configuration
		IFS=$'\n'
		while read -r i; do
			localDirTest="$(grep "localDir=" "$i/config" | cut -d '=' -f 2-)"
			localTreeTest=($(find "$localDirTest" -type d))
			localTree=($(find "$localDir" -type d))
			if [[ -n "$(printf "%s\n" "${localTreeTest[@]}" "${localTree[@]}" | sort | uniq -d)" ]]; then
				printf "Error: the specified directory overlaps with the configuration \'$(basename "$i")\'\n"
				exit 1
			fi
		done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" -mindepth 1 \
			-maxdepth 1 -type d)
		unset IFS

		# generate config and source variables from it
		genConfig

		# format variables
		localDir="${localDir%/}"
		remoteDir="${remoteDir%/}"
		remoteUser="${remoteUser:+$remoteUser@}"
		sshfsOptions=(-o $sshfsOptions)

		# set defaults
		sshOptions=(-o ServerAliveInterval=7 -o ServerAliveCountMax=3)

		# generate file indicating that the initialization process is in progress
		echo "$configName" > "$localDir/.retain-sync_part"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || exit 1

		# check if remote directory is empty
		if [[ -n "$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -mindepth 1')" ]]; then
			printf "\nError: remote directory is not empty\n"
			exit 1
		fi
	else
		echo "Resuming initialization..."

		# read config file
		readConfig "$1"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || \
			exit 1
	fi

	# check if there is enough space on the server
	printf "\nChecking space requirement... "
	remoteSpace=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'df -B 1 "'$remoteDir'"' | tail -n 1 | awk '{print $4}')
	localSize=$(du -sb "$localDir" | awk '{print $1}')
	if [[ $localSize -gt $remoteSpace ]]; then
		printf "\nError: not enough space on the server\n"
		exit 1
	else
		echo "done"
	fi

	# add all local symlinks to the exclude file so they don't get clobbered (this
	# does not include symlinks to directories)
	cat <<-EOF > "$configDir/exclude"
		# This file contains paths to files (not directories) to exclude from syncing.
		#
		# The root of each file path is anchored to the local sync directory (see
		# rsync(1) for details).
		#
		# You can use 'retain-sync exclude' and 'retain-sync include' to easily add or
		# remove whole directories.
	EOF
	find "$localDir" -not -path '*/\.*' -type l -not -xtype d | sed "s|$localDir||g" >> \
		"$configDir/exclude"

	# run if --exclude option was given
	if [[ $optExclude -eq 1 ]]; then
		while read -r i; do
			[[ "$i" =~ ^$ ]] && continue
			[[ "$i" =~ ^# ]] && continue

			# copy file path from input file to exclude file if it exists in
			# the local sync directory
			if echo "${i%/}" | grep -Fxqf <(find "$localDir" -not -path '*/\.*'); then
				find "$i" -not -path '*/\.*' -not -type d | \
					sed "s|$localDir||g" >> "$configDir/exclude"
			fi
		done <"$optExcludeFile"
	fi

	# copy local files to the server
	printf "Copying local files to server... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --exclude=".*" \
		--exclude-from="$configDir/exclude" "$localDir/" \
		"$remoteUser$remoteHost:$remoteDir" && echo "done" || exit 1

	# mount sshfs
	mkdir -p "$configDir/mnt"
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt" || exit 1

	# replace local files with symlinks unless local directory is empty
	if [[ -n "$(find "$localDir" -mindepth 1 -not -path '*/\.*')" ]]; then
		printf "Replacing local files with symbolic links... "
		cp -asf "$configDir"/mnt/* "$localDir" && echo "done"
	fi

	# create priority.csv file containing a list of all files in the tree followed
	# by a starting priority of zero
	echo "# Editing this file by hand is not recommended." > "$configDir/priority.csv"
	find "$configDir/mnt" -not -type d -exec echo '{},0' >> "$configDir/priority.csv" \;

	# create "init" file used to indicate that the directory has been initialized and
	# what the name of its config is
	mv "$localDir/.retain-sync_part" "$localDir/.retain-sync_init"

	# advise user to start/enable the daemon
	printf "\nRun \'systemctl --user start retain-sync@$configName.service\' to start the daemon.\n"
	printf "Run \'systemctl --user enable retain-sync@$configName.service\' to start the daemon automatically on login.\n"
}

syncDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u $lockFD

		# delete temp files
		rm -f "$dirPriorityFile"
		rm -f "$dirTreeFile"
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# remove excluded files from priority.csv
	while read -r i; do
		[[ "$i" =~ ^# ]] && continue
		[[ -z "$i" ]] && continue

		fullPath="$(echo "$configDir/mnt$i" | sed 's/[][()\.^$?*+]/\\&/g')"
		sed -i -e "s|$fullPath,[0-9\.]*$||" -e '/^$/d' "$configDir/priority.csv"
	done <"$configDir/exclude"

	# mount sshfs
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt" || exit 1

	# get list of files that have been created or removed since last sync operation
	printf "Checking for new files... "
	IFS=$'\n'
	# 1) print list of files/symlinks in local directory that aren't in the exclude
	#	 file (making paths relative)
	# 2) concatenate list of files in priority.csv (making paths relative)
	# 3) remove all repeated entries in the list
	diffFiles=($(printf "$(find "$localDir" -not -path '*/\.*' -not -type d | \
		sed "s|$localDir||g" | grep -Fvxf "$configDir/exclude" | sed \
		's|^/||g')\n$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 2- | rev | sed "s|$configDir/mnt/||g")\n" | sort | uniq -u))
	unset IFS

	# find highest priority in the file priority file and add one to it
	newPriority="$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 1 | rev | sort -nr | head -n 1 | \
		awk '{print "scale=6; " $0 "+1"}' | bc)" 2> /dev/null

	# go through files that have chaged since last sync one at a time
	for i in "${diffFiles[@]}"; do
		if grep -Fq "$configDir/mnt/$i" "$configDir/priority.csv"; then
			# file no longer present in local directory, remove from priority file
			sed -i -e "s|$configDir/mnt/$i,[0-9\.]*$||" -e '/^$/d' \
				"$configDir/priority.csv"

			if [[ "${deleteAlways,,}" == "no" ]]; then
				# compute checksums of all files in the user's trash if it hasn't already
				# been done
				IFS=$'\n'
				[[ -z "${trashSums+x}" ]] && \
					trashSums=($(find "${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files" \
						-not -type d -print0 | xargs -0 md5sum --ignore-missing | sort | uniq -w 32))
				unset IFS

				# compute checksum of current file
				fileSum="$(md5sum --ignore-missing "$configDir/mnt/$i")"

				# test if file exists in the user's local trash directory by comparing checksums
				if [[ -n "$(printf "%s\n" "${trashSums[@]}" "$fileSum" | sort | uniq -w 32 -D)" ]]; then
					# file is in trash, delete corresponding file on the server
					ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'rm "'$remoteDir/$i'"' || exit 1
				else
					# file is not in trash, mark corresponding file on the server for deletion
					ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
						'mv "'$remoteDir/$i'" "'$remoteDir'/$(dirname "'$i'")/.$(basename "'$i'").trash"' || \
						exit 1
				fi
			else
				# $deleteAlways is set to 'yes', delete corresponding file on the server
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
					'rm "'$remoteDir/$i'"' || exit 1
			fi
		else
			# new file, set priority so that it's at the top and copy to server
			echo "$configDir/mnt/$i,${newPriority:-0}" >> "$configDir/priority.csv"
			ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
				'mkdir -p "$(dirname "'$remoteDir/$i'")"'
			rsync -e "ssh ${sshOptions[*]}" -asHAXS "$localDir/$i" \
				"$remoteUser$remoteHost:$remoteDir/$i" || exit 1
		fi
	done

	# delete broken symlinks in local directory
	find "$localDir" -xtype l -exec rm '{}' \;
	echo "done"

	# exit if priority.csv is empty
	if ! grep -vq '^#' "$configDir/priority.csv"; then
		echo "Local directory is empty. There is nothing else to do."
		exit 0
	fi

	# create directory priority file containing a list of all directories in the
	# tree
	printf "Sorting directories by priority... "
	dirPriorityFile="$(mktemp)"
	find "$configDir/mnt" -mindepth 1 -type d > "$dirPriorityFile"

	# read directory priority file line-by-line
	while read -r i; do
		# total the priorities of all the files in each directory to get the
		# directory priority
		dirPriority=$(grep -v '^#' "$configDir/priority.csv" | grep "$i" | rev | \
			cut -d ',' -f 1 | rev | tr '\n' '+' | sed 's/\+$/\n/' | \
			awk '{print "scale=6; " $0}'| bc) 2> /dev/null

		# adjust directory priority for the size of the directory
		dirSize=$(du -sb "$i" | awk '{print $1}')
		if [[ $dirSize -eq 0 ]]; then
			dirPriority=0
		else
			# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
			# numbers easier to work with.
			dirPriority=$(echo "scale=6; ${dirPriority:-0}/($dirSize/10485760)" | bc)
		fi

		# write directory priority to file
		sed -i "s|^$i$|$i,$dirPriority|" "$dirPriorityFile"
	done <"$dirPriorityFile"

	# sort directory priority file and remove priorities, leaving just file paths
	awk -F ',' '{print $NF,$0}' "$dirPriorityFile" | sort -rn | \
		cut -d ' ' -f 2- > "$dirPriorityFile.swp"
	mv "$dirPriorityFile.swp" "$dirPriorityFile"
	sed -i 's/,[0-9\.]*$//' "$dirPriorityFile"

	# convert human-readable storage limit to bytes
	storageLimitBytes=$(echo $storageLimit | sed -e 's/K/\*1024/' -e 's/M/\*1048576/' \
		-e 's/G/\*1073741824/' | bc)

	# cut down the directory priority file to only the list of directories that can be
	# stored locally without exceeding the storage limit
	dirTreeFile="$(mktemp)"
	getSyncFiles() {
		syncSize=0
		while read -r i; do
			if [[ $(du -sb "$i" | awk '{print $1}') -gt $storageLimitBytes ]]; then
				# current directory alone is larger than the storage limit, remove from
				# directory priority file
				sed -i -e "s|$i$||" -e '/^$/d' "$dirPriorityFile"
			else
				# get size of current directory in bytes and add it to the total
				# size of the list
				((syncSize+=$(du -sb "$i" | awk '{print $1}')))

				if [[ $syncSize -gt $storageLimitBytes ]]; then
					# total list size has exceeded the storage limit
					if ! grep -Fqxf "$dirTreeFile" "$dirPriorityFile"; then
						# none of the directories in the list have subdirectories,
						# remove current directory from the directory priority file
						# because it is too large to fit within the storage limit
						sed -i -e "s|$i$||" -e '/^$/d' "$dirPriorityFile"
						((syncSize-=$(du -sb "$i" | awk '{print $1}')))
					else
						break
					fi
				else
					# total list size is still within the storage limit
					find "$i" -mindepth 1 -type d >> "$dirTreeFile"

					# check if the while loop has reached the last line of the directory
					# priority file
					if [[ "$(tail -n 1 "$dirPriorityFile")" == "$i" ]]; then
						# the list is complete, break out of loops
						break 2
					fi
				fi
			fi
		done <"$dirPriorityFile"
	}
	getSyncFiles
	while true; do
		# remove subdirectories of directories in the list from the directory priority
		# file, then re-calculate the list with those subdirectories gone
		grep -Fvxf "$dirTreeFile" "$dirPriorityFile" > "$dirPriorityFile.swp"
		mv "$dirPriorityFile.swp" "$dirPriorityFile"
		getSyncFiles
	done
	echo "done"

	# get list of individual files that aren't included in the directory priority file
	printf "Sorting remaining files by priority... "
	IFS=$'\n'
	noSyncFiles=($(find "$configDir/mnt" -not -name '.*.trash' -type f))
	while read -r i; do
		noSyncFiles+=($(find "$i" -not -name '.*.trash' -type f))
	done <"$dirPriorityFile"
	noSyncFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sort | uniq -u))

	if [[ "${syncExtraFiles,,}" == "yes" ]]; then
		# from that list, get list of individual files that can fill the remaining space
		# until the storage limit is reached
		for i in "${noSyncFiles[@]}"; do
			# search for line containing complete file name in priority file
			noSyncSorted+=($(grep -Ex "$(echo "$i" | sed 's/[][()\.^$?*+]/\\&/g'),[0-9\.]*$" \
				"$configDir/priority.csv"))
		done
		for i in "${!noSyncSorted[@]}"; do
			# adjust priority for file size
			currentFile="$(echo "${noSyncSorted[$i]}" | rev | cut -d ',' -f 2- | rev)"
			currentFileSize=$(du -sb "$currentFile" | awk '{print $1}')
			if [[ $currentFileSize -gt 0 ]]; then
				adjustedPriority=$(echo "scale=6; $(echo "${noSyncSorted[$i]}" | rev | \
					cut -d ',' -f 1 | rev)/($currentFileSize/10485760)" | bc)
				noSyncSorted[$i]="$(echo "${noSyncSorted[$i]}" | \
					sed "s/,[0-9\.]*$/,$adjustedPriority/")"
			fi
		done
		noSyncSorted=($(printf "%s\n" "${noSyncSorted[@]}" | awk -F ',' '{print $NF,$0}' | \
			sort -rn | cut -d ' ' -f 2- | rev | cut -d ',' -f 2- | rev))
		unset IFS
		for i in "${noSyncSorted[@]}"; do
			currentFileSize=$(du -sb "$i" | awk '{print $1}')

			# get size of current file in bytes and add it to the total size
			((syncSize+=currentFileSize))

			# check if the total size of the list has exceeded the storage limit
			if [[ $syncSize -gt $storageLimitBytes ]]; then
				# current file is too big, skip to next one
				((syncSize-=currentFileSize))
			else
				# add current file to the extra files list
				extraFiles+=("$i")
			fi
		done
	fi

	# get list of individual files to remove and change their path context
	if [[ "${syncExtraFiles,,}" == "yes" ]]; then
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" "${extraFiles[@]}" | sort | uniq -u | \
			sed "s|$configDir/mnt|$localDir|g"))
		unset IFS
		echo "done"
	else
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sed \
			"s|$configDir/mnt|$localDir|g"))
		unset IFS
		echo "done"
	fi

	# remove files that aren't in the directory priority file or the extra files list
	printf "Removing unused files... "
	printf "%s\0" "${rmFiles[@]}" | xargs -0 rm -f

	# replace missing files with symlinks
	cp -asf "$configDir"/mnt/* "$localDir"

	# remove empty directories
	find "$localDir" -not -path '*/\.*' -type d -empty -delete
	echo "done"

	# download (and remove from the server) excluded files that are still on the server
	printf "Downloading new files... "
	find "$configDir/mnt" -not -type d | sed "s|$configDir/mnt||g" | grep -Fxf \
		"$configDir/exclude" | rsync -e "ssh ${sshOptions[*]}" -asHAXS --files-from=- \
		--remove-source-files "$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1

	# make all paths in directory priority file relative
	sed -i "s|$configDir/mnt/||" "$dirPriorityFile"

	# download directories that are in the directory priority file but not stored
	# locally
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --files-from="$dirPriorityFile" \
		--exclude-from="$configDir/exclude" "$remoteUser$remoteHost:$remoteDir/" \
		"$localDir" || exit 1
	# while read -r i; do
	# 	if find "$localDir" -mindepth 1 -not -path '*/\.*' -type l | grep -Fvxf "$configDir/exclude" | grep -Fxq "$localDir/$i"; then
	# 		rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/$i" \
	# 			"$localDir/$i/.." || exit 1
	# 	fi
	# done <"$dirPriorityFile"

	if [[ "${syncExtraFiles,,}" == "yes" ]]; then
		# fill the remaining space with the highest-priority individual files that haven't
		# already been downloaded
		IFS=$'\n'
		extraFiles=($(printf "%s\n" "${extraFiles[@]}" | sed "s|$configDir/mnt/||"))
		unset IFS
		for i in "${extraFiles[@]}"; do
			if ! find "$localDir" -not -path '*/\.*' -type f | grep -Fq "$localDir/$i"; then
				rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/$i" \
					"$localDir/$i" || exit 1
			fi
		done
	fi
	echo "done"
}

retrieveDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# check if systemd service is running
	systemctl --user status "retain-sync@$configName.service" &> /dev/null
	if [[ $? -eq 0 ]]; then
		echo "Error: retain-sync@$configName.service is running"
		echo "Please stop and disable the service before proceeding."
		exit 1
	fi

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if there is enough free space on the local machine
	printf "Checking space requirement... "
	remoteSize=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'du -sb "'$remoteDir'"' | awk '{print $1}') || exit 1
	localSpace=$(df -B 1 "$localDir" | tail -n 1 | awk '{print $4}')
	if [[ $remoteSize -gt $localSpace ]]; then
		# not enough space
		printf "\nError: not enough space on this machine to retrieve \'$configName\'\n"
		exit 1
	else
		echo "done"
	fi

	# remove symlinks that aren't in the exclude file from local directory
	printf "Removing symbolic links from local directory... "
	find "$localDir" -not -path '*/\.*' -type l | grep -Fxvf \
		<(awk '{print "'$localDir'" $0}' "$configDir/exclude") | \
		xargs -d '\n' rm -f && echo "done"

	# copy files from remote directory back to local directory
	printf "Copying remote files to local machine... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/" \
		"$localDir" && echo "done" || exit 1

	# remove files from the server only if they've been successfully downloaded to the
	# local machine first
	printf "Removing files from server... "
	find "$localDir" -not -path '*/\.*' -type f -print0 | sed "s|$localDir|$remoteDir|g" | \
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'xargs -0 rm -f' || exit 1

	# remove empty directories
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -type d -empty -delete' && \
		echo "done" || exit 1

	# unmount sshfs, remove init file, lock file and config directory
	printf "Cleaning up... "
	fusermount -u "$configDir/mnt" || exit 1
	rm -f "$localDir/.retain-sync_init" "$localDir/.retain-sync_part"
	rm -f "$localDir/.retain-sync_lock"
	rm -r "$configDir"
	echo "done"
}

listConfigs() {
	# get a list of directory paths that have been initialized and the names of their
	# configurations
	IFS=$'\n'
	while read -r i; do
		configName+=($(basename "$i"))
		localDir+=($(grep "localDir=" "$i/config" | cut -d '=' -f 2-))
	done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" \
		-mindepth 1 -maxdepth 1 -type d)
	unset IFS

	if [[ "${#configName[@]}" -eq 0 ]]; then
		printf "\n-- No configs --\n\n"
		return 0
	fi

	# find length of longest configuration name or "Configuration"
	configLength=$(printf "%s\n" "${configName[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	configLength=$((configLength>13 ? configLength:13))

	# find length of longest local directory path or "Local directory"
	dirLength=$(printf "%s\n" "${localDir[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	dirLength=$((dirLength>15 ? dirLength:15))

	# print header
	printf "%-${configLength}s | %-s\n" "Configuration" "Local directory"

	# print horizontal separator
	printf '%.0s-' $(seq 1 $((configLength+1)))
	printf '+'
	printf '%.0s-' $(seq 1 $((dirLength+1)))

	# print rest of table
	paste -d ' ' <(printf "\n%-${configLength}s |" "${configName[@]}") <(printf "\n%-s" "${localDir[@]}")
}

emptyTrash() {
	# When files on the local machine are deleted and copies aren't found in the user's
	# trash, their corresponding files on the server are renamed to mark them as
	# 'deleted' so that they can be recovered. This function allows the user to
	# actually delete said files.

	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# empty trash
	printf "Emptying trash... "
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'find "'$remoteDir'" -type f -name ".*.trash" -print0 | xargs -0 rm' && \
		echo "done" || exit 1
}

excludeFiles() {
	# read config file
	readConfig "$1"
	shift

	if [[ -z "$1" ]]; then
		echo "Error: must specify files to exclude"
		exit 1
	fi

	exDirs=("$@")
	for i in "${exDirs[@]}"; do
		IFS=$'\n'
		# get from input the list of files to exclude
		exFiles=($(find "$i" -not -path '*/\.*' -not -type d | sed "s|$localDir||g"))
		unset IFS

		exDirAbsolute="$(find "$i" -maxdepth 0)"

		# check that file/directory is valid
		if [[ "$exDirAbsolute" == "$localDir" ]]; then
			echo "Error: can not exclude entire local sync directory"
			exit 1
		elif ! find "$localDir" -not -path '*/\.*' | grep -Fxq "${exDirAbsolute%/}"; then
			printf "Error: \'$i\' is not within the local sync directory\n"
			exit 1
		fi

		for i in "${exFiles[@]}"; do
			# add file to exclude file if it's not already there
			if echo "$i" | grep -Fxqf "$configDir/exclude"; then
				printf "Error: \'$localDir$i\' is already in exclude file\n"
			else
				echo "$i" >> "$configDir/exclude"
			fi
		done
	done
}

includeFiles() {
	# read config file
	readConfig "$1"
	shift

	if [[ -z "$1" ]]; then
		echo "Error: must specify files to include"
		exit 1
	fi

	incDirs=("$@")
	for i in "${incDirs[@]}"; do
		IFS=$'\n'
		# get from input the list of files to include
		incFiles=($(find "$i" -not -path '*/\.*' -not -type d | sed "s|$localDir||g"))
		unset IFS

		incDirAbsolute="$(find "$i" -maxdepth 0)"

		# check that file/directory is valid
		if ! find "$localDir" -not -path '*/\.*' | grep -Fxq "${exDirAbsolute%/}"; then
			printf "Error: \'$i\' is not within the local sync directory\n"
			exit 1
		elif printf "%s\n" "${incFiles[@]}" | grep -Fxqf "$configDir/exclude"; then
			printf "Error: \'$i\' is not in the exclude file\n"
			exit 1
		fi

		# remove files from exclude file
		for i in "${incFiles[@]}"; do
			i="$(echo "$i" | sed 's/[][()\.^$?*+]/\\&/g')"
			sed -i -e "s|$i||" -e '/^$/d' "$configDir/exclude"
		done
	done
}

agePriority() {
	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# divide the priority of every file by 1.1
	while read -r i; do
		fileName="$(echo "$i" | rev | cut -d ',' -f 2- | rev)"
		newPriority=$(echo "scale=6; $(echo "$i" | rev | cut -d ',' -f 1 | rev)/1.1" | bc) 2> /dev/null
		sed -i "s|$fileName,[0-9\.]*$|$fileName,${newPriority:-0}|" "$configDir/priority.csv"
	done <"$configDir/priority.csv"
}

case "$1" in
	'')
		echo "Error: missing argument"
		printHelp
		exit 1 ;;
	help|--help)
		printHelp ;;
	initialize)
		shift
		opt=$(getopt -o e: -l exclude: -n 'retain-sync' -- "$@")
		eval set -- "$opt"

		# parse options
		while true; do
			case "$1" in
				-e|--exclude)
					optExclude=1
					optExcludeFile="$2"
					shift 2 ;;
				--)
					shift
					break ;;
				*)
					echo "Error: invalid argument"
					exit 1 ;;
			esac
		done

		initializeDir "$1" ;;
	sync)
		syncDir "$2" ;;
	retrieve)
		retrieveDir "$2" ;;
	list-configs)
		listConfigs ;;
	empty-trash)
		emptyTrash "$2" ;;
	exclude)
		shift
		excludeFiles "$@" ;;
	include)
		shift
		includeFiles "$@" ;;
	age)
		agePriority "$2" ;;
	*)
		printf "Error: \'$1\' is not a valid command\n"
		printHelp
		exit 1 ;;
esac
