#!/usr/bin/env bash

# the current version of the program; this is set by the Makefile
version="@VERSION@"

usage() {
	cat <<-EOF
		usage: retain-sync [GLOBAL_OPTION] COMMAND [COMMAND_OPTION] [COMMAND_ARG]

		Global options:
		        --help		Display this help text and exit.
		        --version	Print version number and exit.
		    -q, --quiet		Suppress all normal output (errors are still printed).

		Commands:
		    initialize [OPTION] PATH
		        Prepare the local directory PATH for syncing by moving it to the server and
		        setting up an sshfs mountpoint in its place.

		        -e, --exclude FILE
		            Get a list of file/directory paths from FILE that will be excluded from
		            syncing, meaning that they will always remain local.

		    sync CONFIG|PATH
		        Update the local and remote directories so that the highest priority files
		        remain local. Also deal with deleted and newly created files. This command
		        accepts the absolute path of a local initialized directory or the name of its
		        configuration.

		    retrieve CONFIG|PATH
		        Retrieve all files from the server and de-initialize the local directory. This
		        command accepts the absolute path of a local initialized directory or the name
		        of its configuration.

		    list-configs
		        Print a table of all initialized directories and the names of their
		        configurations.

		    empty-trash CONFIG|PATH
		        Permanently delete all files on the server that are marked for deletion. This
		        command accepts the absolute path of a local initialized directory or the name
		        of its configuration.
	EOF
}

readConfig() {
	# accepts either the name of a configuration or the absolute path of a local
	# sync directory
	if [[ -d "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$1" ]]; then
			# parameter is a valid config
			configName="$1"
	elif [[ "$1" =~ ^~?/ ]]; then
		# parameter is an absolute path
		if [[ -f "$1/.retain-sync_init" ]]; then
			# parameter is an initialized directory
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_init")
		elif [[ -f "$1/.retain-sync_part" ]]; then
			# directory initialization was interrupted
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_part")
		else
			>&2 printf "Error: \'$1\' is not an initialized directory\n"
			exit 1
		fi
	else
		>&2 printf "Error: \'$1\' is not a valid configuration or an absolute path\n"
		exit 1
	fi
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName

	# source variables from config
	configError=0
	while read -r i; do
		((lineNumber++))

		# line is blank, skip
		[[ "$i" =~ ^$ ]] && continue

		# line is a comment, skip
		[[ "$i" =~ ^# ]] && continue

		# run if line is missing an equals sign
		if ! [[ "$i" =~ = ]]; then
			>&2 echo "Error: line $lineNumber of config file: unrecognized syntax"
			((configError++))
		fi

		# parse option, removing leading/trailing whitespace
		varName="$(cut -d '=' -f 1 <<< "$i" | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')"
		varValue="$(cut -d '=' -f 2- <<< "$i" | sed -e 's/^[ \t]*//' -e \
			's/[ \t]*$//')"

		# check if option is recognized
		if ! echo "$varName" | grep -Fqf <(cat <<-EOF
			localDir
			remoteUser
			remoteHost
			remoteDir
			storageLimit
			sshfsOptions
			deleteAlways
			syncExtraFiles
			inflatePriority
		EOF
		); then
			>&2 printf "Error: line $lineNumber of config file: unrecognized option \'$varName\'\n"
			((configError++))
		fi

		# check if value of boolean options is "yes" or "no"
		if echo "$varName" | grep -qFf <(cat <<-EOF
			deleteAlways
			syncExtraFiles
			inflatePriority
		EOF
		); then
			if [[ "${varValue,,}" != "yes" && "${varValue,,}" != "no" ]]; then
				>&2 printf "Error: line $lineNumber of config file: unrecognized value for boolean option\n"
				((configError++))
			fi
		fi

		# declare variable
		declare -g "$varName"="$varValue"
	done <"$configDir/config"

	# exit if there were errors in config file
	[[ ! $configError -ne 0 ]] || exit 1

	# set defaults
	sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=7,ServerAliveCountMax=3}"
	deleteAlways="${deleteAlways:-no}"
	syncExtraFiles="${syncExtraFiles:-yes}"
	inflatePriority="${inflatePriority:-yes}"
	sshOptions=(-o ServerAliveInterval=7 -o ServerAliveCountMax=3)

	# format variables
	localDir="${localDir%/}"
	remoteDir="${remoteDir%/}"
	remoteUser="${remoteUser:+$remoteUser@}"
	sshfsOptions=(-o "$sshfsOptions")
	storageLimit="$(sed -e 's/K/\*1024/' -e 's/M/\*1048576/' \
		-e 's/G/\*1073741824/' <<< "$storageLimit" | bc)"
	deleteAlways="${deleteAlways,,}"
	syncExtraFiles="${syncExtraFiles,,}"
	inflatePriority="${inflatePriority,,}"

	# escape paths for use in sed substitutions
	localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"
	remoteDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$remoteDir")"
	configDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir")"
}

fileLock() {
	# open lock file
	exec {lockFD}>"$localDir/.retain-sync_lock"
	flock -n $lockFD

	# run if lock file was already open
	if [[ "$?" -ne 0 ]]; then
		>&2 echo "Error: another operation on this configuration is already running"
		exit 1
	fi
}

sshMaster() {
	# add ControlPath to ssh defaults
	sshOptions+=(-S "$XDG_RUNTIME_DIR/retain-sync/%C.socket")

	# create runtime dir if it doesn't already exist
	mkdir -p "$XDG_RUNTIME_DIR/retain-sync"

	# all subsequent ssh commands (excluding sshfs)  will use this master connection
	# instead of reconnecting each time
	coproc sshMaster { ssh "${sshOptions[@]}" -NM "$remoteUser$remoteHost" 2>&1; } || exit 1

	# open file descriptor with stdout of ssh master command
	exec {sshFD}<&${sshMaster[0]}

	# suppress certain output from ssh master command
	while read -ru $sshFD i; do
		if ! echo "$i" | grep -qEf <(cat <<-EOF
			ControlSocket .* already exists, disabling multiplexing
		EOF
		); then
			echo "$i"
		fi
	done &
}

genConfig() {
	# prompt user for name of config
	while true; do
		read -erp "Enter a name for this configuration: " configName
		configName="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$configName")"
		if [[ -z "$configName" ]]; then
			>&2 echo "Error: this value may not be blank"
		elif [[ "$configName" =~ [\ ]+ ]]; then
			>&2 echo "Error: this value may not contain spaces"
		elif [[ "$configName" =~ [^0-9A-Za-z_-]+ ]]; then
			>&2 echo "Error: only alphanumeric characters, hyphens and underscores are allowed"
		else
			break
		fi
	done

	# prompt user for user name on remote machine
	while true; do
		read -erp "Enter your user name on the remote machine (empty to use local user name): " remoteUser
		remoteUser="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteUser")"
		if [[ "$remoteUser" =~ [\ ]+ ]]; then
			>&2 echo "Error: user name may not contain spaces"
		else
			break
		fi
	done

	# prompt user for hostname of remote machine
	while true; do
		read -erp "Enter the hostname, ip address or domain name of the remote machine: " remoteHost
		remoteHost="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteHost")"
		if [[ -z "$remoteHost" ]]; then
			>&2 echo "Error: this value may not be blank"
		elif [[ "$remoteHost" =~ [\ ]+ ]]; then
			>&2 echo "Error: hostname may not contain spaces"
		else
			break
		fi
	done

	# prompt user for directory to sync to on remote machine
	while true; do
		read -erp "Enter the directory to sync to on the remote machine: " remoteDir
		remoteDir="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$remoteDir")"
		if [[ -z "$remoteDir" ]]; then
			>&2 >&2 echo "Error: this value may not be blank"
		elif [[ ! "$remoteDir" =~ ^/ ]]; then
			>&2 echo "Error: must be an absolute path"
		else
			break
		fi
	done

	# prompt user for storage limit
	while true; do
		read -erp "Enter the amount of data to keep synced locally to this machine (accepts K, M or G): " storageLimit
		storageLimit="$(sed -r 's/(^|[^\\])[\"'\'']/\1/g' <<< "$storageLimit")"
		if [[ ! "$storageLimit" =~ [0-9]+[KMG] ]]; then
			>&2 echo "Error: must be a whole number followed by a unit (e.g. 10G)"
		else
			break
		fi
	done

	# set default options
	sshfsOptions="reconnect,ServerAliveInterval=7,ServerAliveCountMax=3"
	deleteAlways="no"
	syncExtraFiles="yes"
	inflatePriority="yes"

	# create config directory
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName
	mkdir "$configDir"

	# create config file
	cat <<-EOF > "$configDir/config"
		#
		# retain-sync config
		#

		# directory to sync on local machine
		localDir=$localDir

		# user name on remote machine (optional)
		remoteUser=$remoteUser

		# hostname, ip address or domain name of remote machine
		remoteHost=$remoteHost

		# directory to sync to on remote machine
		remoteDir=$remoteDir

		# amount of data to keep on local machine (accepts K, M or G)
		storageLimit=$storageLimit

		#-------------------------------------------------------------------------------

		# mount options to pass to sshfs
		#sshfsOptions=$sshfsOptions

		# always delete files from the server when their local counterparts are
		# deleted, even if copies aren't found in the local user's trash
		#deleteAlways=$deleteAlways

		# start syncing individual files once no more whole directories can fit within
		# the storage limit
		#syncExtraFiles=$syncExtraFiles

		# inflate the priority of new local files so that they stick around longer
		#inflatePriority=$inflatePriority
	EOF
}

initializeDir() {
	# function accepts the absolute path of a local directory as a parameter

	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u $lockFD

		# inform user if initialization is interrupted
		if [[ -f "$localDir/.retain-sync_part" ]]; then
			printf "\nInitialization was interrupted.\n"
			printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		fi
	}

	# test if parameter is an absolute path
	if [[ "$1" =~ ^~?/ ]]; then
		# is an absolute path
		localDir="${1%/}" # remove trailing slash
	else
		# not an absolute path
		>&2 echo "Error: must be an absolute path"
		exit 1
	fi

	# check if local directory exists
	if ! [[ -d "$1" ]]; then
		>&2 printf "Error: no such directory \'$localDir\'\n"
		exit 1
	fi

	# check if exclude input file is a valid file
	if [[ -n "$optExcludeFile" ]]; then
		if ! [[ -f "$optExcludeFile" ]]; then
			>&2 echo "Error: input file is invalid"
			exit 1
		fi
	fi

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# don't run if finishing an interrupted initialization
	if [[ ! -f "$localDir/.retain-sync_part" ]]; then
		# check if directory has already been initialized
		if [[ -f "$localDir/.retain-sync_init" ]]; then
			>&2 printf "Error: the specified directory has already been initialized by \'$(cat \
				"$localDir/.retain-sync_init")\'.\n"
			exit 1
		fi

		# check if directory includes the retain-sync config
		if find "$localDir" -type d | grep -q "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync"; then
			>&2 echo "Error: the specified directory contains retain-sync config files"
			exit 1
		fi

		# check if directory overlaps with another retain-sync configuration
		IFS=$'\n'
		while read -r i; do
			localDirTest="$(grep "localDir=" "$i/config" | cut -d '=' -f 2-)"
			localTreeTest=($(find "$localDirTest" -type d))
			localTree=($(find "$localDir" -type d))
			if [[ -n "$(printf "%s\n" "${localTreeTest[@]}" "${localTree[@]}" | sort | uniq -d)" ]]; then
				>&2 printf "Error: the specified directory overlaps with the configuration \'$(basename "$i")\'\n"
				exit 1
			fi
		done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" -mindepth 1 \
			-maxdepth 1 -type d)
		unset IFS

		# generate config and source variables from it
		genConfig

		# set defaults
		sshfsOptions="${sshfsOptions:-reconnect,ServerAliveInterval=7,ServerAliveCountMax=3}"
		sshOptions=(-o ServerAliveInterval=7 -o ServerAliveCountMax=3)

		# format variables
		localDir="${localDir%/}"
		remoteDir="${remoteDir%/}"
		remoteUser="${remoteUser:+$remoteUser@}"
		sshfsOptions=(-o "$sshfsOptions")

		# escape paths for use in sed substitutions
		localDirEsc="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$localDir")"

		# generate file indicating that the initialization process is in progress
		echo "$configName" > "$localDir/.retain-sync_part"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || exit 1

		# check if remote directory is empty
		if [[ -n "$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -mindepth 1')" ]]; then
			>&2 printf "\nError: remote directory is not empty\n"
			exit 1
		fi
	else
		echo "Resuming initialization..."

		# read config file
		readConfig "$1"

		# start ssh master connection
		sshMaster

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || \
			exit 1
	fi

	# check if there is enough space on the server
	printf "\nChecking space requirement... "
	remoteSpace=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'df -B 1 "'$remoteDir'"' | tail -n 1 | awk '{print $4}')
	localSize=$(du -sb "$localDir" | awk '{print $1}')
	if [[ "$localSize" -gt "$remoteSpace" ]]; then
		>&2 printf "\nError: not enough space on the server\n"
		exit 1
	else
		echo "done"
	fi

	# add all local symlinks to the exclude file so they don't get clobbered (this
	# does not include symlinks to directories)
	cat <<-EOF > "$configDir/exclude"
		# This file contains paths to files/directories to exclude from syncing.
		#
		# The root of each file path is anchored to the local initialized directory (see
		# rsync(1) for details).
		#
		# All user-created symbolic links in the local initialized directory are added
		# to this file automatically.
	EOF
	find "$localDir" -not -path '*/\.*' -type l | sed "s|$localDirEsc||g" >> \
		"$configDir/exclude"

	IFS=$'\n'
	localFiles=($(find "$localDir" -mindepth 1 -not -path '*/\.*' | sed "s|$localDirEsc||g"))
	unset IFS

	# run if --exclude option was given
	if [[ "$optExclude" -eq 1 ]]; then
		while read -r i; do
			[[ "$i" =~ ^$ ]] && continue	# skip empty line
			[[ "$i" =~ ^# ]] && continue	# skip commented line

			# add leading slash if it doesn't exist
			if ! [[ "$i" =~ ^/ ]]; then
				i="/$i"
			fi

			# copy file path from input file to exclude file if it exists in
			# the local sync directory
			i="$(sed "s|$localDirEsc||" <<< "$i")"
			if grep -Fxqf <(printf "%s\n" "${localFiles[@]}") <<< "${i%/}"; then
				echo "$i" >> "$configDir/exclude"
			fi
		done <"$optExcludeFile"
	fi

	# copy local files to the server
	printf "Copying local files to server... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --exclude=".*" \
		--exclude-from="$configDir/exclude" "$localDir/" \
		"$remoteUser$remoteHost:$remoteDir" && echo "done" || exit 1

	# mount sshfs
	mkdir -p "$configDir/mnt"
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt" || exit 1

	# replace local files with symlinks unless local directory is empty
	if [[ -n "${localFiles[@]}" ]]; then
		printf "Replacing local files with symbolic links... "
		cp -asf "$configDir"/mnt/* "$localDir" && echo "done"
	fi

	# create priority.csv file containing a list of all files in the tree followed
	# by a starting priority of zero
	echo "# Editing this file by hand is not recommended." > "$configDir/priority.csv"
	find "$configDir/mnt" -not -type d -exec echo '{},0' >> "$configDir/priority.csv" \;

	# create "init" file used to indicate that the directory has been initialized and
	# what the name of its config is
	mv "$localDir/.retain-sync_part" "$localDir/.retain-sync_init"

	# advise user to start/enable the daemon
	printf "\nRun \'systemctl --user start retain-sync@$configName.service\' to start the daemon.\n"
	printf "Run \'systemctl --user enable retain-sync@$configName.service\' to start the daemon automatically on login.\n"
}

syncDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u $lockFD

		# delete temp file
		rm -f "$dirPriorityFile"
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# remove excluded files from priority.csv
	while read -r i; do
		[[ "$i" =~ ^$ ]] && continue # skip line if empty
		[[ "$i" =~ ^# ]] && continue # skip line if a comment

		fullPath="$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$configDir/mnt$i")"
		sed -i -e "s|$fullPath,[0-9\.]*$||" -e '/^$/d' "$configDir/priority.csv"
	done <"$configDir/exclude"

	# mount sshfs
	mountpoint -q "$configDir/mnt" || sshfs "${sshfsOptions[@]}" \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt" || exit 1

	printf "Checking for new files... "

	# read contents of exclude file into an array of file paths
	IFS=$'\n'
	while read -r i; do
		i="$localDir$i"
		[[ -a "$i" ]] && \
			excludeFiles+=($(find "$i" -not -path '*/\.*' -not -type d))
	done <"$configDir/exclude"

	# get list of files that have been created or removed since last sync operation
	#
	# 1) print list of files/symlinks in local directory that aren't in the exclude
	#	 file (making paths relative)
	# 2) concatenate list of files in priority.csv (making paths relative)
	# 3) remove all repeated entries in the list
	diffFiles=($(printf "$(find "$localDir" -not -path '*/\.*' -not -type d | \
		grep -Fvxf <(printf "%s\n" "${excludeFiles[@]}") | \
		sed "s|$localDirEsc/||g")\n$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 2- | rev | sed "s|$configDirEsc/mnt/||g")\n" | sort | uniq -u))
	unset IFS

	# find highest priority in the file priority file and add 1 to it
	newPriority="$(grep -v '^#' "$configDir/priority.csv" | rev | \
		cut -d ',' -f 1 | rev | sort -nr | head -n 1 | \
		awk '{print "scale=6; " $0 "+1"}' | bc)" 2> /dev/null

	# go through files that have chaged since last sync one at a time
	for i in "${diffFiles[@]}"; do
		if grep -Fq "$configDir/mnt/$i" "$configDir/priority.csv"; then
			# file no longer present in local directory, remove from priority file
			sed -i -e "s|$configDirEsc/mnt/$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i"),[0-9\.]*$||" \
				-e '/^$/d' "$configDir/priority.csv"

			if [[ "$deleteAlways" == "no" ]]; then
				# compute checksums of all files in the user's trash if it hasn't already
				# been done
				IFS=$'\n'
				[[ -z "${trashSums+x}" ]] && \
					trashSums=($(find "${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files" \
						-not -type d -not -type l -print0 | xargs -0 md5sum | sort | \
						uniq -w 32))
				unset IFS

				# compute checksum of current file
				fileSum="$(md5sum "$configDir/mnt/$i")"

				# test if file exists in the user's local trash directory by comparing checksums
				if [[ -n "$(printf "%s\n" "${trashSums[@]}" "$fileSum" | sort | uniq -w 32 -D)" ]]; then
					# file is in trash, delete corresponding file on the server
					ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'rm -f "'$remoteDir/$i'"' || exit 1
				else
					# file is not in trash, mark corresponding file on the server for deletion
					ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
						'mv "'$remoteDir/$i'" "'$remoteDir'/$(dirname "'$i'")/.$(basename "'$i'").trash"' || \
						exit 1
				fi
			else
				# $deleteAlways is set to 'yes', delete corresponding file on the server
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
					'rm -f "'$remoteDir/$i'"' || exit 1
			fi
		else
			# new file
			if [[ -L "$localDir/$i" ]]; then
				# file is a symlink, add to exclude file
				echo "/$i" >> "$configDir/exclude"
			else
				# file is not a symlink
				if [[ "$inflatePriority" == "yes" ]]; then
					# set priority so that it's at the top
					echo "$configDir/mnt/$i,${newPriority:-0}" >> "$configDir/priority.csv"
				else
					# set priority to zero
					echo "$configDir/mnt/$i,0" >> "$configDir/priority.csv"
				fi

				# copy to server
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
					'mkdir -p "$(dirname "'$remoteDir/$i'")"'
				rsync -e "ssh ${sshOptions[*]}" -asHAXS "$localDir/$i" \
					"$remoteUser$remoteHost:$remoteDir/$i" || exit 1
			fi
		fi
	done

	# delete broken symlinks in local directory
	find "$localDir" -xtype l -exec rm '{}' \;
	echo "done"

	# exit if priority.csv is empty
	if ! grep -vq '^#' "$configDir/priority.csv"; then
		echo "Local directory is empty. There is nothing else to do."
		exit 0
	fi

	# create directory priority file containing a list of all directories in the
	# tree
	printf "Sorting directories by priority... "
	dirPriorityFile="$(mktemp)"
	find "$configDir/mnt" -mindepth 1 -type d > "$dirPriorityFile"

	# read directory priority file line-by-line
	while read -r i; do
		# total the priorities of all the files in each directory to get the
		# directory priority
		dirPriority=$(grep -v '^#' "$configDir/priority.csv" | grep -F "$i" | rev | \
			cut -d ',' -f 1 | rev | tr '\n' '+' | sed 's/\+$/\n/' | \
			awk '{print "scale=6; " $0}'| bc) 2> /dev/null

		# get the size of the directory in bytes
		dirSize="$(du -sb "$i" | awk '{print $1}')"

		# set minimum dir size of 16 bytes to perclude a "divide by zero"
		# error with bc
		if [[ "$dirSize" -lt 16 ]]; then
			dirSize=16
		fi

		# adjust directory priority for the number of files and the size of the
		# directory
		# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
		# numbers easier to work with
		dirPriority=$(echo "scale=6; ${dirPriority:-0}/($dirSize/10485760)" | bc)

		# write directory priority to file
		sed -i "s|^$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")$|$i,$dirPriority|" \
			"$dirPriorityFile"
	done <"$dirPriorityFile"

	# sort directory priority file and remove priorities, leaving just file paths
	awk -F ',' '{print $NF,$0}' "$dirPriorityFile" | sort -rn | \
		cut -d ' ' -f 2- > "$dirPriorityFile.swp"
	mv "$dirPriorityFile.swp" "$dirPriorityFile"
	sed -i 's/,[0-9\.]*$//' "$dirPriorityFile"

	# cut down the directory priority file to only the list of directories that can be
	# stored locally without exceeding the storage limit
	getSyncFiles() {
		syncSize=0
		while read -r i; do
			dirSize="$(du -sb "$i" | awk '{print $1}')"
			if [[ "$dirSize" -gt $storageLimit ]]; then
				# current directory alone is larger than the storage limit, remove from
				# directory priority file
				sed -i -e "s|$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")$||" \
					-e '/^$/d' "$dirPriorityFile"
			else
				# get size of current directory in bytes and add it to the total
				# size of the list
				((syncSize+=dirSize))

				if [[ "$syncSize" -gt $storageLimit ]]; then
					# total list size has exceeded the storage limit
					if ! grep -Fqxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile"; then
						# none of the directories in the list have subdirectories,
						# remove current directory from the directory priority file
						# because it is too large to fit within the storage limit
						sed -i -e "s|$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i")$||" \
							-e '/^$/d' "$dirPriorityFile"
						((syncSize-=dirSize))
					else
						break
					fi
				else
					# total list size is still within the storage limit
					dirPriorityTree+=($(find "$i" -mindepth 1 -type d))

					# check if the while loop has reached the last line of the directory
					# priority file
					if [[ "$(tail -n 1 "$dirPriorityFile")" == "$i" ]]; then
						# the list is complete, break out of loops
						break 2
					fi
				fi
			fi
		done <"$dirPriorityFile"
	}
	getSyncFiles
	while true; do
		# break if file is empty
		[[ ! -s "$dirPriorityFile" ]] && break

		# remove subdirectories of directories in the list from the directory priority
		# file, then re-calculate the list with those subdirectories gone
		grep -Fvxf <(printf "%s\n" "${dirPriorityTree[@]}") "$dirPriorityFile" > "$dirPriorityFile.swp"
		mv "$dirPriorityFile.swp" "$dirPriorityFile"
		getSyncFiles
	done
	echo "done"

	# get list of individual files that aren't included in the directory priority file
	printf "Sorting remaining files by priority... "
	IFS=$'\n'
	noSyncFiles=($(find "$configDir/mnt" -not -name '.*.trash' -not -type d))
	while read -r i; do
		noSyncFiles+=($(find "$i" -not -name '.*.trash' -not -type d))
	done <"$dirPriorityFile"
	noSyncFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sort | uniq -u))

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# from that list, get list of individual files that can fill the remaining space
		# until the storage limit is reached

		for i in "${noSyncFiles[@]}"; do
			# search for line containing complete file name in priority file
			noSyncSorted+=($(grep -Ex "$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$i"),[0-9\.]*$" \
				"$configDir/priority.csv"))
		done

		# adjust priority for file size
		for i in "${!noSyncSorted[@]}"; do
			currentFile="$(rev <<< "${noSyncSorted[$i]}" | cut -d ',' -f 2- | rev)"
			currentFileSize=$(du -sb "$currentFile" | awk '{print $1}')

			# set minimum file size of 16 bytes to perclude a "divide by zero"
			# error with bc
			if [[ "$currentFileSize" -lt 16 ]]; then
				currentFileSize=16
			fi

			# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
			# numbers easier to work with
			adjustedPriority=$(echo "scale=6; $(rev <<< "${noSyncSorted[$i]}" | \
				cut -d ',' -f 1 | rev)/($currentFileSize/10485760)" | bc)
			noSyncSorted[$i]="$(sed "s/,[0-9\.]*$/,$adjustedPriority/" <<< "${noSyncSorted[$i]}")"
		done

		# sort files by priority
		noSyncSorted=($(printf "%s\n" "${noSyncSorted[@]}" | awk -F ',' '{print $NF,$0}' | \
			sort -rn | cut -d ' ' -f 2- | rev | cut -d ',' -f 2- | rev))
		unset IFS

		for i in "${noSyncSorted[@]}"; do
			currentFileSize=$(du -sb "$i" | awk '{print $1}')

			# get size of current file in bytes and add it to the total size
			((syncSize+=currentFileSize))

			# check if the total size of the list has exceeded the storage limit
			if [[ "$syncSize" -gt "$storageLimit" ]]; then
				# current file is too big, skip to next one
				((syncSize-=currentFileSize))
			else
				# add current file to the extra files list
				extraFiles+=("$i")
			fi
		done
	fi

	# get list of individual files to remove and change their path context
	if [[ "$syncExtraFiles" == "yes" ]]; then
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" "${extraFiles[@]}" | sort | uniq -u | \
			sed "s|$configDirEsc/mnt|$localDir|g"))
		unset IFS
		echo "done"
	else
		IFS=$'\n'
		rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sed \
			"s|$configDirEsc/mnt|$localDir|g"))
		unset IFS
		echo "done"
	fi

	# remove files that aren't in the directory priority file or the extra files list
	printf "Removing unused files... "
	printf "%s\0" "${rmFiles[@]}" | xargs -0 rm -f

	# replace missing files with symlinks
	cp -asn "$configDir"/mnt/* "$localDir" &> /dev/null

	# remove empty directories
	find "$localDir" -not -path '*/\.*' -type d -empty -delete
	echo "done"

	# download (and remove from the server) excluded files that are still on the server
	printf "Downloading new files... "
	find "$configDir/mnt" -not -type d | sed "s|$configDirEsc/mnt||g" | \
		grep -Fxf <(printf "%s\n" "${excludeFiles[@]}") | \
		rsync -e "ssh ${sshOptions[*]}" -asHAXS --files-from=- --remove-source-files \
		"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1

	# find file paths in directory priority file
	IFS=$'\n'
	while read -r i; do
		dirPriorityArray+=($(find "$i" -not -type d))
	done <"$dirPriorityFile"
	unset IFS
	printf "%s\n" "${dirPriorityArray[@]}" > "$dirPriorityFile"

	# make all paths in directory priority file relative
	sed -i "s|$configDirEsc/mnt/||" "$dirPriorityFile"

	# download directories that are in the directory priority file but not stored
	# locally
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --files-from="$dirPriorityFile" \
		--exclude-from="$configDir/exclude" "$remoteUser$remoteHost:$remoteDir/" \
		"$localDir" || exit 1

	if [[ "$syncExtraFiles" == "yes" ]]; then
		# fill the remaining space with the highest-priority individual files that haven't
		# already been downloaded
		printf "%s\n" "${extraFiles[@]}" | sed "s|$configDirEsc/mnt/||g" | \
			rsync -e "ssh ${sshOptions[*]}" -asHAXS --files-from=- \
			"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1
	fi
	echo "done"
}

retrieveDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# check if systemd service is running
	systemctl --user status "retain-sync@$configName.service" &> /dev/null
	if [[ "$?" -eq 0 ]]; then
		>&2 echo "Error: retain-sync@$configName.service is running"
		echo "Please stop and disable the service before proceeding."
		exit 1
	fi

	# run cleanup function on script exit
	trap cleanup EXIT

	# start ssh master connection
	sshMaster

	# check if there is enough free space on the local machine
	printf "Checking space requirement... "
	remoteSize=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'du -sb "'$remoteDir'"' | awk '{print $1}') || exit 1
	localSpace=$(df -B 1 "$localDir" | tail -n 1 | awk '{print $4}')
	if [[ "$remoteSize" -gt "$localSpace" ]]; then
		# not enough space
		>&2 printf "\nError: not enough space on this machine to retrieve \'$configName\'\n"
		exit 1
	else
		echo "done"
	fi

	# read contents of exclude file into an array of file paths
	printf "Removing symbolic links from local directory... "
	while read -r i; do
		i="$localDir$i"
		[[ -a "$i" ]] && \
			excludeFiles+=($(find "$i" -not -path '*/\.*' -not -type d))
	done <"$configDir/exclude"

	# remove symlinks that aren't in the exclude file from the local directory
	find "$localDir" -not -path '*/\.*' -type l | \
		grep -Fxvf <(printf "%s\n" "${excludeFiles[@]}") | \
		xargs -d '\n' rm -f && echo "done"

	# move files from remote directory back to local directory
	printf "Moving remote files to local machine... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --remove-source-files \
		"$remoteUser$remoteHost:$remoteDir/" "$localDir" || exit 1

	# remove empty directories
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -type d -empty -delete' && \
		echo "done" || exit 1

	# unmount sshfs, remove init file, lock file and config directory
	printf "Cleaning up... "
	if mountpoint -q "$configDir/mnt" || [[ ! -d "$configDir/mnt" ]]; then
		fusermount -u "$configDir/mnt" || exit 1
	fi
	rm -f "$localDir/.retain-sync_init" "$localDir/.retain-sync_part"
	rm -f "$localDir/.retain-sync_lock"
	rm -r "$configDir"
	echo "done"
}

listConfigs() {
	# get a list of directory paths that have been initialized and the names of their
	# configurations
	IFS=$'\n'
	while read -r i; do
		configName+=($(basename "$i"))
		localDir+=($(grep "localDir=" "$i/config" | cut -d '=' -f 2-))
	done < <(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" \
		-mindepth 1 -maxdepth 1 -type d)
	unset IFS

	if [[ "${#configName[@]}" -eq 0 ]]; then
		printf "\n-- No configs --\n\n"
		return 0
	fi

	# find length of longest configuration name or "Configuration"
	configLength=$(printf "%s\n" "${configName[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	configLength=$((configLength>13 ? configLength:13))

	# find length of longest local directory path or "Local directory"
	dirLength=$(printf "%s\n" "${localDir[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	dirLength=$((dirLength>15 ? dirLength:15))

	# print header
	printf "%-${configLength}s | %-s\n" "Configuration" "Local directory"

	# print horizontal separator
	printf '%.0s-' $(seq 1 $((configLength+1)))
	printf '+'
	printf '%.0s-' $(seq 1 $((dirLength+1)))

	# print rest of table
	paste -d ' ' <(printf "\n%-${configLength}s |" "${configName[@]}") <(printf "\n%-s" "${localDir[@]}")
}

emptyTrash() {
	# When files on the local machine are deleted and copies aren't found in the user's
	# trash, their corresponding files on the server are renamed to mark them as
	# 'deleted' so that they can be recovered. This function allows the user to
	# actually delete said files.

	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# empty trash
	printf "Emptying trash... "
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'find "'$remoteDir'" -not -type d -name ".*.trash" -print0 | xargs -0 rm' && \
		echo "done" || exit 1
}

agePriority() {
	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# divide the priority of every file by 1.1
	while read -r i; do
		fileName="$(rev <<< "$i" | cut -d ',' -f 2- | rev)"
		newPriority=$(echo "scale=6; $(rev <<< "$i" | cut -d ',' -f 1 | rev)/1.1" | bc) 2> /dev/null
		sed -i "s|$(sed 's/[][()\.^$?*+]/\\&/g' <<< "$fileName"),[0-9\.]*$|$fileName,${newPriority:-0}|" \
			"$configDir/priority.csv"
	done <"$configDir/priority.csv"
}

# parse global options
for ((i=1; i<=$#; i++)); do
	# Note: getopt isn't being used here because getopt doesn't allow for
	# parameters to have their own options

	# if parameter is multiple short options sandwitched together, separate them
	if [[ "${@:$i:1}" =~ ^-[^-\ ]{2,} ]]; then
		set -- ${@:1:$((i-1))} $(sed -e 's/\(\w\)/ -\1/g' -e 's/^- //' <<< "${@:$i:1}") ${@:$((i+1))}
	# if parameter is a long option with an argument separated by an equals
	# sign, replace the equals sign with a space
	elif [[ "${@:$i:1}" =~ ^--[^-\ ] ]]; then
		set -- ${@:1:$((i-1))} $(sed -e 's/=/ /' <<< "${@:$i:1}") ${@:$((i+1))}
	fi
done

# read global options
while [[ "$1" =~ ^- ]]; do
	case "$1" in
		--help)
			usage
			exit ;;
		--version)
			echo "retain-sync $version"
			exit ;;
		-q|--quiet)
			exec > /dev/null
			shift ;;
		*)
			>&2 echo "Error: unknown option"
			>&2 printf "Try \'retain-sync --help\' for more information.\n"
			exit 1 ;;
	esac
done

# read subcommands
case "$1" in
	'')
		>&2 echo "Error: missing argument"
		>&2 printf "Try \'retain-sync --help\' for more information.\n"
		exit 1 ;;
	initialize)
		shift

		# parse options
		for ((i=1; i<=$#; i++)); do
			# Note: getopt isn't being used here because getopt doesn't allow for
			# parameters to have their own options

			# if parameter is multiple short options sandwitched together, separate them
			if [[ "${@:$i:1}" =~ ^-[^-\ ]{2,} ]]; then
				set -- ${@:1:$((i-1))} $(sed -e 's/\(\w\)/ -\1/g' -e 's/^- //' <<< "${@:$i:1}") ${@:$((i+1))}
			# if parameter is a long option with an argument separated by an equals
			# sign, replace the equals sign with a space
			elif [[ "${@:$i:1}" =~ ^--[^-\ ] ]]; then
				set -- ${@:1:$((i-1))} $(sed -e 's/=/ /' <<< "${@:$i:1}") ${@:$((i+1))}
			fi
		done

		# read options
		while [[ "$1" =~ ^- ]]; do
			case "$1" in
				-e|--exclude)
					optExclude=1
					optExcludeFile="$2"
					shift 2 ;;
				*)
					>&2 echo "Error: unknown option"
					>&2 printf "Try \'retain-sync --help\' for more information.\n"
					exit 1 ;;
			esac
		done

		initializeDir "$1" ;;
	sync)
		syncDir "$2" ;;
	retrieve)
		retrieveDir "$2" ;;
	list-configs)
		listConfigs ;;
	empty-trash)
		emptyTrash "$2" ;;
	age)
		agePriority "$2" ;;
	*)
		>&2 printf "Error: \'$1\' is not a valid command\n"
		>&2 printf "Try \'retain-sync --help\' for more information.\n"
		exit 1 ;;
esac
