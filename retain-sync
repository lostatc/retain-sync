#!/usr/bin/env bash

formatVars() {
	# format variables
	localDir="${localDir%/}"
	remoteDir="${remoteDir%/}"
	remoteUser="${remoteUser:+$remoteUser@}"
	sshfsOptions="-o $sshfsOptions"

	# set defaults
	sshOptions=(-o ServerAliveInterval=10 -o ServerAliveCountMax=2)
}

readConfig() {
	# accepts either the name of a configuration or the absolute path of a local
	# sync directory
	if [[ -d "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$1" ]]; then
			# parameter is a valid config
			configName="$1"
	elif [[ "$1" =~ ^~?/ ]]; then
		# parameter is an absolute path
		if [[ -f "$1/.retain-sync_init" ]]; then
			# parameter is an initialized directory
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_init")
		elif [[ -f "$1/.retain-sync_part" ]]; then
			# directory initialization was interrupted
			localDir="${1%/}"
			configName=$(cat "$localDir/.retain-sync_part")
		else
			printf "Error: \'$1\' is not an initialized directory\n"
			exit 1
		fi
	else
		printf "Error: \'$1\' is not a valid configuration or an absolute path\n"
		exit 1
	fi
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName

	# source variables from config
	configError=0
	while read i; do
		((lineNumber++))

		# line is blank, skip
		[[ "$i" =~ ^$ ]] && continue

		# line is a comment, skip
		[[ "$i" =~ ^# ]] && continue

		# run if line is missing an equals sign
		if ! [[ "$i" =~ = ]]; then
			echo "Error: line $lineNumber of config file: unrecognized syntax"
			((configError++))
		fi

		# parse option
		varName="$(echo "$i" | cut -d '=' -f 1)"
		varValue="$(echo "$i" | cut -d '=' -f 2-)"

		# run if option is unrecognized
		if ! echo "$varName" | grep -qFf <(cat <<-EOF
			localDir
			remoteUser
			remoteHost
			remoteDir
			storageLimit
			sshfsOptions
		EOF
		); then
			printf "Error: line $lineNumber of config file: unrecognized option \'$varName\'\n"
			((configError++))
		fi

		# declare variable
		declare -g "$varName"="$varValue"
	done <"$configDir/config"

	# exit if there were errors in config file
	[[ ! $configError -ne 0 ]] || exit 1

	# format variables and set defaults
	formatVars
}

fileLock() {
	# open lock file
	exec {lockFD}>"$localDir/.retain-sync_lock"
	flock -n $lockFD

	# run if lock file was already open
	if [[ $? -ne 0 ]]; then
		echo "Error: another operation on this configuration is already running"
		exit 1
	fi
}

sshMaster() {
	# add ControlPath to ssh defaults
	sshOptions+=(-S "$XDG_RUNTIME_DIR/retain-sync/%C.socket")

	# create runtime dir if it doesn't already exist
	mkdir -p "$XDG_RUNTIME_DIR/retain-sync"

	# all subsequent ssh commands (excluding sshfs)  will use this master connection
	# instead of reconnecting each time
	coproc sshMaster { ssh "${sshOptions[@]}" -NM "$remoteUser$remoteHost" 2>&1; }

	# open file descriptor 3 with stdout of ssh master command
	exec 3<&${sshMaster[0]}

	# suppress certain output from ssh master command
	while read -u 3 i; do
		if ! echo "$i" | grep -qEf <(cat <<-EOF
			ControlSocket .* already exists, disabling multiplexing
		EOF
		); then
			echo "$i"
		fi
	done &
}

genConfig() {
	# prompt user for name of config
	while true; do
		read -ep "Enter a name for this configuration: " configName
		configName="${configName//[\"\']/}"
		if [[ -z "$configName" ]]; then
			echo "Error: this value may not be blank"
		elif [[ "$configName" =~ [\ ]+ ]]; then
			echo "Error: this value may not contain spaces"
		elif [[ "$configName" =~ [^0-9A-Za-z_-]+ ]]; then
			echo "Error: only alphanumeric characters, hyphens and underscores are allowed"
		else
			break
		fi
	done

	# prompt user for user name on remote machine
	while true; do
		read -ep "Enter your user name on the remote machine (empty to use local user name): " remoteUser
		remoteUser="${remoteUser//[\"\']/}"
		if [[ "$remoteUser" =~ [\ ]+ ]]; then
			echo "Error: user name may not contain spaces"
		else
			break
		fi
	done

	# prompt user for hostname of remote machine
	while true; do
		read -ep "Enter the hostname, ip address or domain name of the remote machine: " remoteHost
		remoteHost="${remoteHost//[\"\']/}"
		if [[ -z "$remoteHost" ]]; then
			echo "Error: this value may not be blank"
		elif [[ "$remoteHost" =~ [\ ]+ ]]; then
			echo "Error: hostname may not contain spaces"
		else
			break
		fi
	done

	# prompt user for directory to sync to on remote machine
	while true; do
		read -ep "Enter the directory to sync to on the remote machine: " remoteDir
		remoteDir="${remoteDir//[\"\']/}"
		if [[ -z "$remoteDir" ]]; then
			echo "Error: this value may not be blank"
		elif [[ ! "$remoteDir" =~ ^/ ]]; then
			echo "Error: must be an absolute path"
		else
			break
		fi
	done

	# prompt user for storage limit
	while true; do
		read -ep "Enter the amount of data to keep synced locally to this machine (accepts K, M or G): " storageLimit
		storageLimit="${storageLimit//[\"\']/}"
		if [[ ! "$storageLimit" =~ [0-9]+[KMG] ]]; then
			echo "Error: must be a whole number followed by a unit (e.g. 10G)"
		else
			break
		fi
	done

	# set default sshfs options
	sshfsOptions="reconnect,ServerAliveInterval=10,ServerAliveCountMax=2"

	# create config directory
	configDir=${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync/$configName
	mkdir "$configDir"

	# create config file
	cat <<-EOF > "$configDir/config"
		#
		# retain-sync config
		#

		# directory to sync on local machine
		localDir=$localDir

		# user name on remote machine (optional)
		remoteUser=$remoteUser

		# hostname, ip address or domain name of remote machine
		remoteHost=$remoteHost

		# directory to sync to on remote machine
		remoteDir=$remoteDir

		# amount of data to keep on local machine (accepts K, M or G)
		storageLimit=$storageLimit

		# mount options to pass to sshfs
		sshfsOptions=$sshfsOptions
	EOF
}

initializeDir() {
	# function accepts the absolute path of a local directory as a parameter

	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# drop the lock on this configuration (necessary becuase of sshfs)
		flock -u $lockFD

		# inform user if initialization is interrupted
		if [[ -f "$localDir/.retain-sync_part" ]]; then
			printf "\nInitialization was interrupted.\n"
			printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		fi
	}

	# test if parameter is an absolute path
	if [[ ! "$1" =~ ^~?/ ]]; then
		# not an absolute path
		echo "Error: must be an absolute path"
		exit 1
	else
		# is an absolute path
		localDir="${1%/}" # remove trailing slash
		configDir=
	fi

	# lock this configuration
	fileLock

	# don't run if finishing an interrupted initialization
	if [[ ! -f "$localDir/.retain-sync_part" ]]; then
		# check if directory has already been initialized
		[[ -f "$localDir/.retain-sync_init" ]] && \
			printf "Error: the specified directory directory has already been initialized by \'$(cat \
			"$localDir/.retain-sync_init")\'.\n" && exit 1

		# check if directory includes the retain-sync config
		if find "$localDir" -type d | grep -q "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync"; then
			echo "Error: the specified directory contains retain-sync config files"
			exit 1
		fi

		# check if directory overlaps with another retain-sync configuration
		IFS=$'\n'
		for i in $(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" -mindepth 1 -maxdepth 1 -type d); do
			localDirTest="$(grep "localDir=" "$i/config" | cut -d '=' -f 2-)"
			localTreeTest=($(find "$localDirTest" -type d))
			localTree=($(find "$localDir" -type d))
			if [[ -n "$(printf "%s\n" "${localTreeTest[@]}" "${localTree[@]}" | sort | uniq -d)" ]]; then
				printf "Error: the specified directory overlaps with the configuration \'$(basename "$i")\'\n"
				exit 1
			fi
		done
		unset IFS

		# generate config and source variables from it
		genConfig

		# format variables and set defaults
		formatVars

		# generate file indicating that the initialization process is in progress
		echo "$configName" > "$localDir/.retain-sync_part"

		# start ssh master connection
		sshMaster

		# run cleanup function on script exit
		trap cleanup EXIT

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || exit 1

		# check if remote directory is empty
		if [[ -n "$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -mindepth 1')" ]]; then
			printf "\nError: remote directory is not empty\n"
			exit 1
		fi
	else
		echo "Resuming initialization..."

		# read config file
		readConfig "$1"

		# start ssh master connection
		sshMaster

		# run cleanup function on script exit
		trap cleanup EXIT

		# create remote directory if it doesn't already exist
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'mkdir -p "'$remoteDir'"' || exit 1
	fi


	# check if there is enough space on the server
	printf "\nChecking space requirement... "
	remoteSpace=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'df -B 1 "'$remoteDir'"' | tail -n 1 | awk '{print $4}')
	localSize=$(du -sb "$localDir" | awk '{print $1}')
	if [[ $localSize -gt $remoteSpace ]]; then
		printf "\nError: not enough space on the server\n"
		exit 1
	else
		echo "done"
	fi

	# copy local files to the server
	printf "Copying local files to server... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS --exclude=".*" "$localDir/" \
		"$remoteUser$remoteHost:$remoteDir" && echo "done" || exit 1

	# mount sshfs
	mkdir -p "$configDir/mnt"
	mountpoint -q "$configDir/mnt" || sshfs $sshfsOptions \
		"$remoteUser$remoteHost:$remoteDir" "$configDir/mnt" || exit 1

	# replace local files with symlinks unless local directory is empty
	if [[ -n "$(find "$localDir" -mindepth 1 -not -path '*/\.*')" ]]; then
		printf "Replacing local files with symbolic links... "
		cp -asf "$configDir/mnt/"* "$localDir" && echo "done"
	fi

	# create priority.csv file containing a list of all files in the tree followed
	# by a starting priority of zero
	echo "# editing this file by hand is not recommended" > "$configDir/priority.csv"
	find "$configDir/mnt" -type f -exec echo '{},0' >> "$configDir/priority.csv" \;

	# create "init" file used to indicate that the directory has been initialized and
	# what the name of its config is
	mv "$localDir/.retain-sync_part" "$localDir/.retain-sync_init"

	# advise user to start/enable the daemon
	printf "\nRun \'systemctl --user start retain-sync@$configName.service\' to start the daemon.\n"
	printf "Run \'systemctl --user enable retain-sync@$configName.service\' to start the daemon automatically on login.\n"
}

syncDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null

		# delete temp files
		rm -f "$dirPriorityFile"
		rm -f "$dirTreeFile"
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# start ssh master connection
	sshMaster

	# run cleanup function on script exit
	trap cleanup EXIT

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# get list of files that have been created or removed since last sync operation
	printf "Checking for new files... "
	IFS=$'\n'
	diffFiles=($(printf "$(find "$localDir" -not -path '*/\.*' -type f -o -type l | \
		sed "s|$localDir/||g")\n$(cat "$configDir/priority.csv" | grep -v '^#' | rev | \
		cut -d ',' -f 2- | rev | sed "s|$configDir/mnt/||g")\n" | sort | uniq -u))
	unset IFS

	# find highest priority in the file priority file and add one to it
	newPriority="$(cat "$configDir/priority.csv" | grep -v '^#' | rev | \
		cut -d ',' -f 1 | rev | sort -nr | head -n 1 | \
		awk '{print "scale=6; " $0 "+1"}' | bc)" 2> /dev/null

	# go through files that have chaged since last sync one at a time
	for i in "${diffFiles[@]}"; do
		if grep -Fq "$configDir/mnt/$i" "$configDir/priority.csv"; then
			# file no longer present in local directory, remove from priority file
			sed -i -e "s|$configDir/mnt/$i,[0-9\.]*$||" -e '/^$/d' \
				"$configDir/priority.csv"

			# compute checksums of all files in the user's trash if it hasn't already
			# been done
			IFS=$'\n'
			[[ -z "${trashSums+x}" ]] && \
				trashSums=($(find "${XDG_DATA_HOME:-$HOME/.local/share}/Trash/files" \
				-type f -print0 | xargs -0 md5sum | sort | uniq -w 32))
			unset IFS

			# compute checksum of current file
			fileSum="$(md5sum "$configDir/mnt/$i")"

			# test if file exists in the user's local trash directory by comparing checksums
			if [[ -n "$(printf "%s\n" "${trashSums[@]}" "$fileSum" | sort | uniq -w 32 -D)" ]]; then
				# file is in trash, delete corresponding file on the server
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" "rm $remoteDir/$i" || exit 1
			else
				# file is not in trash, mark corresponding file on the server for deletion
				ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
					'mv "'$remoteDir/$i'" "'$remoteDir'/$(dirname "'$i'")/.$(basename "'$i'").trash"' || \
					exit 1
			fi
		else
			# new file, set priority so that it's at the top and copy to server
			echo "$configDir/mnt/$i,${newPriority:-0}" >> "$configDir/priority.csv"
			ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
				'mkdir -p "$(dirname "'$remoteDir/$i'")"'
			rsync -e "ssh ${sshOptions[*]}" -asHAXS "$localDir/$i" \
				"$remoteUser$remoteHost:$remoteDir/$i" || exit 1
		fi
	done
	echo "done"

	# exit if priority.csv is empty
	if ! grep -vq '^#' "$configDir/priority.csv"; then
		echo "Local directory is empty. There is nothing else to do."
		exit 0
	fi

	# create directory priority file containing a list of all directories in the
	# tree
	printf "Sorting directories by priority... "
	dirPriorityFile=$(mktemp)
	find "$configDir/mnt" -mindepth 1 -type d > $dirPriorityFile
	# read directory priority file line-by-line
	while read i; do
		# total the priorities of all the files in each directory to get the
		# directory priority
		dirPriority=$(cat "$configDir/priority.csv" | grep -v '^#' | grep "$i" | rev | \
			cut -d ',' -f 1 | rev | tr '\n' '+' | sed 's/\+$/\n/' | \
			awk '{print "scale=6; " $0}'| bc) 2> /dev/null

		# adjust directory priority for the size of the directory
		dirSize=$(du -sb "$i" | awk '{print $1}')
		if [[ $dirSize -eq 0 ]]; then
			dirPriority=0
		else
			# Note: '10485760' (10MiB) was arbitrarily picked to make the resulting
			# numbers easier to work with.
			dirPriority=$(echo "scale=6; ${dirPriority:-0}/($dirSize/10485760)" | bc)
		fi

		# write directory priority to file
		sed -i "s|^$i$|$i,$dirPriority|" $dirPriorityFile
	done <$dirPriorityFile

	# sort directory priority file and remove priorities, leaving just file paths
	awk -F ',' '{print $NF,$0}' $dirPriorityFile | sort -rn | \
		cut -d ' ' -f 2- > $dirPriorityFile.swp
	mv $dirPriorityFile.swp $dirPriorityFile
	sed -i 's/,[0-9\.]*$//' $dirPriorityFile

	# convert human-readable storage limit to bytes
	storageLimitBytes=$(echo $storageLimit | sed -e 's/K/\*1024/' -e 's/M/\*1048576/' \
		-e 's/G/\*1073741824/' | bc)

	# cut down the directory priority file to only the list of directories that can be
	# stored locally without exceeding the storage limit
	dirTreeFile=$(mktemp)
	getSyncFiles() {
		syncSize=0
		while read i; do
			if [[ $(du -sb "$i" | awk '{print $1}') -gt $storageLimitBytes ]]; then
				# current directory alone is larger than the storage limit, remove from
				# directory priority file
				sed -i -e "s|$i$||" -e '/^$/d' $dirPriorityFile
			else
				# get size of current directory in bytes and add it to the total
				# size of the list
				((syncSize+=$(du -sb "$i" | awk '{print $1}')))

				if [[ $syncSize -gt $storageLimitBytes ]]; then
					# total list size has exceeded the storage limit
					if ! grep -Fqxf $dirTreeFile $dirPriorityFile; then
						# none of the directories in the list have subdirectories,
						# remove current directory from the directory priority file
						# because it is too large to fit within the storage limit
						sed -i -e "s|$i$||" -e '/^$/d' $dirPriorityFile
						((syncSize-=$(du -sb "$i" | awk '{print $1}')))
					else
						break
					fi
				else
					# total list size is still within the storage limit
					echo "$(find "$i" -mindepth 1 -type d)" >> $dirTreeFile

					# check if the while loop has reached the last line of the directory
					# priority file
					if [[ "$(cat $dirPriorityFile | tail -n 1)" == "$i" ]]; then
						# the list is complete, break out of loops
						break 2
					fi
				fi
			fi
		done <$dirPriorityFile
	}
	getSyncFiles
	while true; do
		# remove subdirectories of directories in the list from the directory priority
		# file, then re-calculate the list with those subdirectories gone
		grep -Fvxf $dirTreeFile $dirPriorityFile > $dirPriorityFile.swp
		mv $dirPriorityFile.swp $dirPriorityFile
		getSyncFiles
	done
	echo "done"

	# get list of individual files that aren't included in the directory priority file
	IFS=$'\n'
	noSyncFiles=($(find "$configDir/mnt" -not -name '.*.trash' -type f))
	while read i; do
		noSyncFiles+=($(find "$i" -not -name '.*.trash' -type f))
	done <$dirPriorityFile
	noSyncFiles=($(printf "%s\n" "${noSyncFiles[@]}" | sort | uniq -u))

	# from that list, get list of individual files that can fill the remaining space
	# until the storage limit is reached
	for i in "${noSyncFiles[@]}"; do
		# search for line containing complete file name in priority file
		noSyncSorted+=($(grep -xE "$(echo "$i" | sed 's/[][()\.^$?*+]/\\&/'),[0-9\.]*$" \
			"$configDir/priority.csv"))
	done
	for i in "${!noSyncSorted[@]}"; do
		# adjust priority for file size
		currentFile="$(echo "${noSyncSorted[$i]}" | rev | cut -d ',' -f 2- | rev)"
		currentFileSize=$(du -sb "$currentFile" | awk '{print $1}')
		if [[ $currentFileSize -gt 0 ]]; then
			adjustedPriority=$(echo "scale=6; $(echo "${noSyncSorted[$i]}" | rev | \
				cut -d ',' -f 1 | rev)/($currentFileSize/10485760)" | bc)
			noSyncSorted[$i]="$(echo "${noSyncSorted[$i]}" | \
				sed "s/,[0-9\.]*$/,$adjustedPriority/")"
		fi
	done
	noSyncSorted=($(printf "%s\n" "${noSyncSorted[@]}" | awk -F ',' '{print $NF,$0}' | \
		sort -rn | cut -d ' ' -f 2- | rev | cut -d ',' -f 2- | rev))
	unset IFS
	for i in "${noSyncSorted[@]}"; do
		currentFileSize=$(du -sb "$i" | awk '{print $1}')

		# get size of current file in bytes and add it to the total size
		((syncSize+=$currentFileSize))

		# check if the total size of the list has exceeded the storage limit
		if [[ $syncSize -gt $storageLimitBytes ]]; then
			# current file is too big, skip to next one
			((syncSize-=$currentFileSize))
		else
			# add current file to the extra files list
			extraFiles+=("$i")
		fi
	done

	# get list of individual files to remove and change their path context
	IFS=$'\n'
	rmFiles=($(printf "%s\n" "${noSyncFiles[@]}" "${extraFiles[@]}" | sort | uniq -u | \
		sed "s|$configDir/mnt|$localDir|"))
	unset IFS

	# remove files that aren't in the directory priority file or the extra files list
	printf "Removing unused files... "
	printf "%s\0" "${rmFiles[@]}" | xargs -0 rm -f && echo "done"

	# replace missing files with symlinks
	cp -asn "$configDir/mnt/"* "$localDir" &> /dev/null

	# remove empty directories
	find "$localDir" -not -path '*/\.*' -type d -empty -delete

	# make all paths in directory priority file relative
	sed -i "s|$configDir/mnt/||" $dirPriorityFile

	# download directories that are in the directory priority file but not stored
	# locally
	printf "Downloading new files... "
	while read i; do
		if find "$localDir" -mindepth 1 -not -path '*/\.*' -type l | grep -Fq "$localDir/$i"; then
			rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/$i" \
				"$localDir/$i/.." || exit 1
		fi
	done <$dirPriorityFile

	# fill the remaining space with the highest-priority individual files that haven't
	# already been synced
	IFS=$'\n'
	extraFiles=($(printf "%s\n" "${extraFiles[@]}" | sed "s|$configDir/mnt/||"))
	unset IFS
	for i in "${extraFiles[@]}"; do
		if ! find "$localDir" -not -path '*/\.*' -type f | grep -Fq "$localDir/$i"; then
			rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/$i" \
				"$localDir/$i" || exit 1
		fi
	done
	echo "done"
}

retrieveDir() {
	cleanup() {
		# stop ssh master connection
		ssh -O exit -S "$XDG_RUNTIME_DIR"/retain-sync/%C.socket "$remoteUser$remoteHost" &> /dev/null
	}

	# read config file
	readConfig "$1"

	# lock this configuration
	fileLock

	# start ssh master connection
	sshMaster

	# run cleanup function on script exit
	trap cleanup EXIT

	# check if there is enough free space on the local machine
	printf "Checking space requirement... "
	remoteSize=$(ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'du -sb "'$remoteDir'"' | awk '{print $1}') || exit 1
	localSpace=$(df -B 1 "$localDir" | tail -n 1 | awk '{print $4}')
	if [[ $remoteSize -gt $localSpace ]]; then
		# not enough space
		printf "\nError: not enough space on this machine to retrieve \'$configName\'\n"
		exit 1
	else
		echo "done"
	fi

	# remove symlinks from local directory
	printf "Removing symbolic links from local directory... "
	find "$localDir" -type l -print0 | xargs -0 rm -f && echo "done"

	# copy files from remote directory back to local directory
	printf "Copying remote files to local machine... "
	rsync -e "ssh ${sshOptions[*]}" -asHAXS "$remoteUser$remoteHost:$remoteDir/" \
		"$localDir" && echo "done" || exit 1

	# remove files from the server only if they've been successfully downloaded to the
	# local machine first
	printf "Removing files from server... "
	find "$localDir" -not -path '*/\.*' -type f -print0 | sed "s|$localDir|$remoteDir|g" | \
		ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'xargs -0 rm -f' || exit 1

	# remove empty directories
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" 'find "'$remoteDir'" -type d -empty -delete' && \
		echo "done" || exit 1

	# unmount sshfs, remove init file and remove config directory
	printf "Cleaning up... "
	fusermount -u "$configDir/mnt" || exit 1
	rm -f "$localDir/.retain-sync_init" "$localDir/.retain-sync_part"
	rm -r "$configDir"
	echo "done"
}

listConfigs() {
	# get a list of directory paths that have been initialized and the names of their
	# configurations
	IFS=$'\n'
	for i in $(find "${XDG_CONFIG_HOME:-$HOME/.config}/retain-sync" -mindepth 1 -maxdepth 1 -type d); do
		configName+=($(basename "$i"))
		localDir+=($(grep "localDir=" "$i/config" | cut -d '=' -f 2-))
	done
	unset IFS

	if [[ "${#configName[@]}" -eq 0 ]]; then
		printf "\n-- No configs --\n\n"
		return 0
	fi

	# find length of longest configuration name or "Configuration"
	configLength=$(printf "%s\n" "${configName[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	configLength=$(($configLength>13 ? $configLength:13))

	# find length of longest local directory path or "Local directory"
	dirLength=$(printf "%s\n" "${localDir[@]}" | awk \
		'{if (length > x) {x = length}}END{print x}')
	dirLength=$(($dirLength>15 ? $dirLength:15))

	# print header
	printf "%-${configLength}s | %-s\n" "Configuration" "Local directory"

	# print horizontal separator
	printf '%.0s-' $(seq 1 $(($configLength+1)))
	printf '+'
	printf '%.0s-' $(seq 1 $(($dirLength+1)))

	# print rest of table
	paste -d ' ' <(printf "\n%-${configLength}s |" "${configName[@]}") <(printf "\n%-s" "${localDir[@]}")
}

emptyTrash() {
	# When files on the local machine are deleted and copies aren't found in the user's
	# trash, their corresponding files on the server are renamed to mark them as
	# 'deleted' so that they can be recovered. This function allows the user to
	# actually delete said files.

	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# empty trash
	printf "Emptying trash... "
	ssh "${sshOptions[@]}" "$remoteUser$remoteHost" \
		'find "'$remoteDir'" -type f -name ".*.trash" -print0 | xargs -0 rm' && \
		echo "done" || exit 1
}

agePriority() {
	# read config file
	readConfig "$1"

	# check if initialization was interrupted
	if [[ -f "$localDir/.retain-sync_part" ]]; then
		echo "Initialization of this directory was interrupted."
		printf "Please run \'retain-sync initialize\' to complete it or \'retain-sync retrieve\' to cancel it.\n"
		exit 1
	fi

	# divide the priority of every file by 1.1
	while read i; do
		fileName="$(echo "$i" | rev | cut -d ',' -f 2- | rev)"
		newPriority=$(echo "scale=6; $(echo "$i" | rev | cut -d ',' -f 1 | rev)/1.1" | bc) 2> /dev/null
		sed -i "s|$fileName,[0-9\.]*$|$fileName,${newPriority:-0}|" "$configDir/priority.csv"
	done <"$configDir/priority.csv"
}

case "$1" in
	'')
		echo "Error: missing argument"
		echo "help"
		exit 1 ;;
	initialize)
		initializeDir "$2"
		shift 2 ;;
	sync)
		syncDir "$2"
		shift 2 ;;
	retrieve)
		retrieveDir "$2"
		shift 2 ;;
	list-configs)
		listConfigs
		shift ;;
	empty-trash)
		emptyTrash "$2"
		shift 2 ;;
	age)
		agePriority "$2"
		shift 2 ;;
	help|--help)
		echo "help"
		shift 1 ;;
	*)
		printf "Error: \'$1\' is not a valid command\n"
		echo "help"
		exit 1 ;;
esac
